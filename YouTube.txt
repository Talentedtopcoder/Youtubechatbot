so in this one you're going to be
installing the jdk android studio
uh and everything that is needed to to
make sure that you can create a react
native app on windows so where do we
start so we're going to be starting here
so this is the react native doctor
so this is a tool that allows us to know
what exactly we need
but for it to run we are going to need
to have npm installed which you can get
by installing node.js so let's go ahead
and install node.js we're going to study
node.js for 10.17 but any version that
will be here when you visit the site is
going to be acceptable so also we are
going to need the jdk
all right okay so let's go ahead and
first install node.js
and then we are going to take a look at
the react native doctor tool so make
sure you you make sure make sure it is
added to path so don't change anything
automatically set up to skip the
defaults here
all right so now we have node.js
and we can verify by i'm going to bring
up the the command line so i'm going to
be using the command prompt so we can
check if node was installed by typing in
node
v
and you can see we have node here so
let's go ahead and now use the use the
doctor tool to be able to tell what
exactly we need so we're going to need
to run this command here so i'm going to
copy it
yep
just run that
you can see this one in here says we
need to run this in a react native
project so normally you would use this
for the
for diagnosing your project so if maybe
something's if your project is not
running you would run this in your
project and then it's going to go ahead
and check these things for now don't
worry let's go ahead and now install the
things it says we are missing the jdk
android studio and then the sdk on the
android studio website i'm going to
click download android studio we need to
accept the agreement
so i'm going to click ok so also we need
to download the
jdk so jdk is the java development kit
basically all the software that's
android users it is built on top of java
so it's gonna need java to be installed
on our machine in order for it to run
properly
so i'm gonna go here and on this side
you want to go to a specific installer
for your current machine
so i'm gonna click this one since i'm on
a 64-bit machine i will accept the times
all right so once my login is correct
once your login is correct then you can
go ahead and
click install and it's going to
go ahead and confirm and it's going to
go ahead and start to to download the
jdk so one other thing we're going to
need to download is a text editor now we
could go ahead and set up android studio
make it work to build our react native
app completely
but that's not what we want for sure we
want the agility that we get building
react apps
so sure let's get vs code so i imagine
you have it but if you don't
download it too then i'm going to now
install the jdk so i'm going to double
click on that the terms of software
changed okay we just need to get that
jdk setup all right so it's going to
give us development 2 source code and
jre
that's okay it's going to install the
jdk here and also the jre so this is
just software that it needs behind the
scenes so let's keep the defaults
all right so our java installation is
done let's go ahead and close here
so now that we have the jdk installed
let's go ahead and also install android
studio so i'm gonna double click on that
so we'll go through the android studio
installation setup so click next here
so right here we wanted to install the
android virtual device now the android
virtual device is just a term for
the emulator
so we want to go ahead and install the
emulator because we use that to test our
applications
so let's go ahead and continue we'll
choose only the defaults it wants to
create shortcuts
okay go ahead
android studio has completed
installation so wanna click next on it
and let's start it because you're gonna
need to install a few other things
android studio has actually evolved so
much over the years
so every time we open it we have a new
ui
so
yeah looks pretty neat so what you need
to do here is click on more options and
we want to go to the sdk manager
so on the sdk manager we want to make
sure that we install
this
so we want to make sure that we install
the
api level 31 the api level 30 or 31
so much so one needs to be updated
somehow
so i'm gonna go ahead and click ok
so we also need to set up the virtual
device so you can click on on
more actions
and then you click on evd so the lvd
manager enables us to manage
virtual devices
so then we can click on create virtual
device
then you want to click the device you
want
i'll click next
so we need to set up a system image if
you don't have one setup you can
download one when it finishes you can
use it right now i have two setup here
so these two
i guess download the android studio so
we want to click next
then we are going to click finish
and that's going to go ahead and create
it
so now i'm going to start it here
okay so now i can close the lvd manager
and here we have the emulator being open
we have the emulator opening up
so down here
if i click on sdk manager
uh we got sdk tools
we have some things here we need to set
up
so we have the the sdk tools we must
have this so make sure that one is there
if it if it's not check it and then you
can click okay and then you should be
able to install it
the emulator check it
and this hyper v for amd
okay so that's good one other thing i
want you guys to install is the google
usb driver so this makes it easier to do
usb debugging so if you're having any
issues with with usb debugging make sure
you have this and also if you're in an
intel on an intel machine you're going
to need to also install this
all right
so let's click that and let's confirm
that
we want this to install we get the the
the license we accept the license
and it should be pretty fast and click
finish
okay so now that we are done there now
we can go ahead and run our doctor
command again
so whenever you see an error so wherever
you see this just know it is missing so
you can see it didn't get the jdk so for
us to be able to fix it we are going to
go to our computer so i'm going to click
the file explorer then i'm going to
click on this pc
so we want to right click and click on
properties
right then we want to go to advanced
system settings
and go to environment variables
so here we need to set up java and add
it to our path so the android path was
actually added automatically by android
studio
so to find our java home or where our
java lives now what we want to do is we
want to go to
this pc then you want to go to your
local disk so you go to program files
so java is here so you want to click on
it and then you see where we have the
jdk here you want to click on that and
this is what we want to pick
so i'm going to copy this so just right
click
and copy
so in our in our environment variables
on here we want to click new
and we want to say java underscore home
and we can set that value to
to the one we just copped
so click ok
so this is for the current user this was
added to the system
so here we can also do new
java underscore home
so let's set the value it's going to be
this very one
so also we have this path variable so if
we click on this
we can also add it here
all right click ok
let's also add it on the path for the
system
so click edit
and
add it here so we need to do new
and add it
click ok
save everything
and up click here to apply we have the
android home setup we have the java home
setup
now we have android 600 we have android
studio setup we have the
emulator setup now we can go ahead and
create a react native project
i'm going to cd onto the desktop
so i'm going to call this i'm going to
call this mobile projects
so here let's create a react native app
using npx so when you install node.js it
comes with npm
so they have a tool called npx that
allows you to run a package without
actually installing it so when i run
react native
in it
so i'm gonna do example project here
then run it
so we run react npx react native init
example project
and now it's going to go ahead and start
to
basically create a react native project
for us all right so it looks like things
went well
so what we need to do is cd into the
project so i'm going to see it in the
example project
so cd
what is this
so cd into example project
so so now if you go to vs code we can
say open folder
and we want to go to where
we want to go to
where we created the project so mine is
in mobile projects
so i'm going to click on my mobile
projects this is the example project so
i'm going to select this and it should
be able to open here
so now we have our react native project
so i'm going to bring up the terminal
so if we go to package.json file so
package.json
let's take a look at the available
scripts
so we need to start the react native
packaging so that's like
the dev server that's going to be
watching
that's going to be watching our changes
and communicating them to the connected
devices
so here we want to run npm stats or npms
that
we also have the script to run it on
android which is
android here
so we want to also now run our
application on android so i'm going to
create a new terminal i'm going to
create a new command prompt window
and here we do npm
run
android like this
so now things are good we are able to
keep developing if you have any issues
here be sure to ask a question
hey guys except so welcome to this
tutorial series on jungle so in this one
we are going to be building a complete
project using Django and JavaScript so
for those of you who don't know what
jungle is so jungle is a web framework
for for python that enables you to
easily create powerful publications so
we are going to be building out most of
the common features you'd find in new
york apps so for example we'll do
suppose we'll do like the crud
operations you know we'll set up a first
class database for our website you can
see we'll be able to do like exact
search for for our data see we do like
pagination for all our data and then
I'll show you how to integrate chats the
chat JS library to graphically visualize
this data in a way that can be easy to
understand I'll show you how to try work
with data actually so putting this data
from the database and then formatting it
in a way that it's going to make a lot
of meaningful on the user interface so
for example here you see we are showing
out expenses in the last three months so
we have a comparison of the of the last
three months so you see we are going to
be able to do like some logic to find
out how much was spent in the first week
of this mass of the other month even of
the third month and then we are going to
be able to visually like visually lay
them out on the chart like this so it's
gonna be like quite intermediate in one
way or the other but then if you manage
to stick around and complete it it's
gonna teach us a lot about data
structures in Python and how think about
the common problems cause this is what
most apps will require so you see we
have an authentication system built out
here so users I want people to sign up
for username via email they get an
e-mail verification link so if they
forget their passwords they're going to
be able to to reset their password
for example could come in here and put
in I use an email and then it should
send me a password reset link then I'll
show you how to do like attacks close to
the server so you can validate a
username in real time so we don't wait
for a user to send a request so these
kinds of things are the things you would
normally find in reward apps then I'm
going out I'm gonna go ahead and show
you let me first actually come back in
here so you can take a whole two of
everything so here is I will be able to
create to create like records I'll show
you how to work with the file system the
OS moji to take work with JSON pull out
files pass them read from them and then
close them so it's going to be a lots
that will cover you so users are going
to be able to like create expenses so
for example I can come in here choose a
currency let's say let's say can be any
currency so this can be a description
save that then you see we have this
fresh messages to to violate user input
before we save it and then you see we
are able to passes the data even when we
have errors here
so let's see let me just get the dates
here maybe plus 25th that we did this
explains if I save now you can see that
it's saved and then it's added here as
you can see it's here and of course we
can edit it and then of course now when
you come to the editing you see these
details are prefilled so you can just
edit and then we'll be able to like
remove it so if I remove this one we get
this dialog and by the guys we are using
bootstrap for the UI was we won't be
focusing more on the UI will focus on
the jungle stuff so that's why I'm going
to use bootstrap on here so you see if I
delete it it's gone and these chats of
course update updated
accord
England can see that this is now
changing okay so if we if I show you
about the income will be able to do that
record our income so here you can come
in and add like a new record maybe we
made like like 5k maybe from business
let's say close the deal I really you
can customize this to to any type of
like report you want okay so the Norwich
even he of course will be transferable
to anything else that you want to build
you see I am not sure if I have
mentioned about like searching the
server from here Bing and attacks such
as you can see you can search through
multiple records so we can search by
date by any any attribute that you see
about about an income is that the thing
that's mostly we'll find in in real apps
and just running them from here will
give you a solid grasp on how to to
attempt those problems as you'll find
here I have something called summaries
so this is where we're going to go in
depth with like getting data formatting
data you will learn more about all those
use Python utility functions like map
being reducing filtering so it's gonna
be very interesting if we stick around
so you can see we are going to be able
to like look look out for that all the
reports in the current yeah and then we
are going to graph them accordingly
so here you can see in a poll we sum up
every income will go to a poll and then
we will return this and this is gonna be
for all the months so you can think
about the logic that goes into that I'm
going to be going over everything from A
to Z with nothing left
I'll show you like the thought process
that I usually go through to come up
with something like this hopefully some
of you guys can get an idea about how to
go about solving problems like this so
here it's basically the same thing but
for the current week so if you kind of
think about it
we all got all the data we have
then we want to like fill that down to
the current week and pick out what's
happened on Monday Tuesday August
ripples here we are going to learn about
how to get this data in a form that the
UI we will do the same thing for the
expenses and then notice that we have
like loading indicators when the users
network is the quite slow so if I could
throw to my network or I'm going Stan
online too slow 3G and then try to
rewrite this page so this will will show
like if I use a it's on the slow network
this is how it's gonna appear so now if
I go here like here you can see that
they each chose the user that something
is coming up until it comes and then it
goes away
so we'll do all that stuff using
javascript it's gonna be a lot to learn
on this one I hope you guys will stick
around and you'll learn a lot from me
but also planning this up and oh we are
going to build it I have laid out like
the project yeah
on this on this app would be water
tracker so I'm going to be following
this to implement the features and then
of course I'm going to be posting all
the code on github if anyone needs to
look at it and compare with they wanted
to have and by the guys I didn't mention
about one of the most powerful features
that we have here in Django that's I'm
gonna cover in depth which is the the
Django admin so I'm quite fed up with
the my internet speed
let me quite click it back to normal so
we cannot sure to save some time so let
me go back to the first 3G and then to
go to the admin section here you can see
we have an admin area I'm going to show
you how to customize everything of
course this is not the default one show
you how to use a custom car as custom
logos so let me go again here see now
when I login we learn about how to
customize everything that you see yeah
I'll show you how to add things like
this is details here such adding which
filters to search for search by adding
everything here isn't something called
mordioux that mean so it's gonna be
alert it's gonna be it's gonna be
overwhelming but I promise if you stick
around you will get to learn a ton from
me so I think I'm gonna be stopping the
video here I will come back and we
started off by great setting up jungle
so with that said if you like this kind
of content please subscribe to the
channel so you get an turn on the
notifications so you can get notified
when I post a new video about this kind
of thing I hope you stick around and we
learn and I was think I'll see you in
the next video
hey guys what's up so welcome to this
tutorial series
on flask so in this tutorial series we
are going to be building
a link bookmarking api such that users
can be able to
save links that they may want to check
out in the future so our backend is
going to be multi-user meaning that we
are going to need a
way for users to be able to create
accounts and also to log in
so when they log in we will be giving
them an access token that they can use
to access the protected endpoints like
the ones to create a bookmark
to retrieve all bookmarks so we'll also
have another
endpoint that is going to be used to
refresh a token
for security purposes the access token
that we get on login will be short-lived
so whenever user logs in we are going to
give them a pair of keys
an access token and a refresh token so
whenever the access token expires
we are going to be using that refresh
token to make a call to the
to the token refresh endpoint where we
can get
a new access token and keep our users
logged in what we are looking at right
now is the api documentation
and we are going to be using swagger to
document it
so every endpoint we add in the backend
will will have to be documented
somehow such that we can be able to give
this documentation to like other
developers that might want to make a
mobile app for this api
or if they want to make a front-end
using react or angular or vue
or whatever the front-end developers
have these days
they can use this to know how to talk to
api and they can
make it work for the user so here in
postman you can see that over here we go
ahead and make a request to the
sign up endpoint and we get a 201
created which means that a resource was
created on our server
and then we get a response of that user
send back then from the endpoint to
login
we get the two tokens and then we get
the other extra
users information who has logged in and
then with these tokens
we can start to access protected
endpoints like this one to get a list of
bookmarks
this one to add a bookmark one thing
you'll notice here is on the period of a
single bookmark
we have a short show area and a long url
and also we have the visits
property so the visits property is used
to track
how many times we visited this url
because it's common that we might
bookmark things but we might not check
them out
so this is going to be used to give the
user an insight on the things they have
not checked out
so the way we are doing that is by in
the backend implementing
a url shortener service
so over here you can set we have a field
for the short url
so whenever a user enters a url like
this we go ahead and shorten it on our
server
and on our server we create a unique url
for it
so now when i try to access let's say i
want to access this
localhost 455 slash z5b
if i go to a chrome and i type it like
here
notice that this should be going to our
local server but when i click there
you notice that it goes to our server
and then it redirects
here to the real to the real
url so this way we are able to tell that
the user actually checked out one of the
links they bookmarked
by having to implement the shortener
service so it's it's quite interesting
how it's implemented so
i'm sure you're gonna learn some cool
things as we implement that
now over here we have an endpoint for
retrieving the stats
you can see that for each of the urls we
can track how many times it was visited
such that maybe on the front end we can
sort our
bookmarks by the ones we've not checked
out so we make our backend api
more flexible and more realistic so that
is going to be it for the introductory
video
if you are really interested in building
these kinds of apps i highly recommend
you subscribe to the channel
because i'm going to be releasing a lot
of videos showing you guys how to build
these kinds of apis mobile apps web apps
from scratch
so please consider subscribing thanks
and i'll see you in the next video
so in this video we're going to go ahead
and create our first project
and make sure that you can get started
writing card so to get started the only
requirement you're going to need here is
python
so make sure you have python installed
when you install python with the normal
process
you're going to have pip and then we are
going to be using pip to install our
our project dependencies like flask and
alike so to get started i'm here in my
terminal so if you're on a mac or linux
open up your terminal if you're on
windows
open up your command prompt but first
you want to first verify that you have
python
so go ahead and type in python in your
terminal
when i type in python you can see that i
get the python share open up
by default it opens up python 2 so this
is not what we want so i'm going to quit
here
now on macro linux when installed python
3 you can use that by typing in python 3
so when i type in python 3 you can set i
have python 3.7.7
so let me just click this one again so
verify that you have python
so if i do python 3 version
you can set i have to you can see my
version
now to check if you have pip you can
type in pip
so since i'm using a mac you can type in
pip3
version and then you can see that we get
pip3 version being listed so if you're
in windows
be sure to you to type in pip or python
without putting the three
it should be able to work automatically
if you install following the
default process so once you have that we
are going to need a way to manage our
virtual environment
now if you think about python projects
you might be working on
like two or three python projects on
your computer and a lot of the times you
want each of those projects
to have its own dependencies in one
place such that you can be able to move
the project around computers or even
put it on a server for hosting without
having to
look for the packages again so we are
going to be creating a virtual
environment that will hold all our
project dependencies now for us to
create a virtual environment you're
going to be
using a tool called virtual env so if
you're on mac or linux
go ahead and install it using pip3 so
you can type in peep 3d install
version env like this so go ahead and
run that
so when i run that you can set mine
finished so fast because i already had
it
on windows go ahead and type in pip
install
virtual pnv
so once you install that now we can use
battery and
create a batch environment so over here
i'm first gonna create a folder that
will contain all our project files
so i'm gonna call this bookmarks rest
api and then i'm gonna cd into it so
bookmarks
so now that we are in our bookmarks rest
api we can go ahead and create our
virtual environment in here
so to create a batch environment we can
use the tool we just installed so
type in virtual env and then you give it
an environment name so mine is going to
be called v
e and v like this notice how i'm unable
to create it like this
so if you ever face that issue be sure
to run this using
python 3 so you can do python 3 minus
m m is for module signifying that we
want to run
this module using python three so i'm
going to run that
and when you run that you can see that
now if i do an errors
on windows you have to type in like a
dir to see
if the folder was created so if i do an
ls you can see that now we have the
folder
for our batch environment and now we
need to activate it
so now to activate it on the linux go
ahead and type in source
then vnv then go to bin
then you want to source in the activate
script this one
so when i do that you can see that my
virtual environment is activated and we
can tell
by seeing the name of the virtual
environment here
so if you ever want to maybe deactivate
it
you can type in deactivate
and it should deactivate it so if you're
in windows and you try typing in source
it will not work
be sure to cd into your virtual
environment then scripts then activate
the platform
and then you should be able to see that
your version your virtual environment is
activated like this
so now we are here if we do a python
version you can see that the python
we're using now
is the one that is tied to our project
and we don't have to do python 3 anymore
and if you ever wanted to know which
part which python you're using or
the where the python using is you can
type
which python and then you should be able
to see
where it is so the one are using is in
our virtual environment
so good now let's go ahead and install
flask so it installed first go ahead and
do pip
install flask like this so it's going to
go ahead and install flask
so flask also uses some other
dependencies
so you can see that it installs like
ginger too it's dangerous
click typing extensions
flask also depends on this now our
project also depends on these with flask
so now that we have flask installed i'm
going to open up this project in vs code
so on my computer i can type in chord
dot and then it should be able to open
in vs code so you can see here we have
our project
and then we have the virtual environment
so i'm going to open the integrated
terminal in vs code because with this
one i don't have to switch between
windows i can just code
i can just work in one editor and things
will be fine
so over here the first thing you're
going to need to do is we are going to
create
an entry point to our server so out here
i'm going to create a file called
app.pi so in the update this is where
we're going to be writing our python
code
but before we do that let me go ahead
and activate my virtual environment
again because
when you open a new terminal session you
have to reactivate the virtual
environment so let me go ahead and do
that
so so now we are going to go ahead and
we create
a very basic flask app so to create a
very basic flask cap we are going to
import flask
from flask so from frask import
flask so here we need to create an
instance of flask and that will be our
app so we can do like app
equals flash and then we pass in double
underscore
name double underscore so when we
instantiate flask it needs a way to know
where it is being
configured from and that's why you're
passing this this then the name data
so once we are done with this now we can
go ahead and recreate a very
basic route so this can sometimes be
called an endpoint
and we can create that by using the app
and then we use a decorator
we do app dot and then after this we do
an http method so for example if we
wanted to do a get request we'll do
app.get and then inside here and then
we'll find the route
so we are going to listen for when a
user goes to our home page
and then we're going to create a
function to handle that so here we can
just have a function
so for this function we're going to just
be returning hello world
hello world like this
so don't mind this so now to be able to
test out our application if
to be able to run it we need to go in
our terminal and then we need to tell
flask
a few things one of them is going to be
the environment we are running in
so over here we can do export flask
underscore and then we are going to set
that one to
development so by default flask will
assume that we are running in production
so you need to tell it that we are
running in development so that it can
give us like debugging errors and all
that stuff
so let's run that so another thing we
need to define is the path to our
flask app so we can do that by doing
export flask
app and then and that will be the part
of the module that has our first cap in
our case it is app
so we can do up like this and now we can
run flask
run in our terminal and once we run that
you should be able to see that we have
serving flask app
and then we have the environment you're
running on which is development and then
that turns on like debug mode
and all this other stuff so now if we
click on this url
and come to the browser you can see that
we have our hello world
now the browser can only help us to do
get requests
but later we're going to be looking at
how to use postman to also work with
other
methods like like post or delete or get
so let's have another basic endpoint
over here
so i'm going to have slash hello so
since we are going to be building an api
then it makes sense to start working
with json already
so over here so flask comes with some
utilities that can enable us to work
with
json and one we are going to be working
with is jsonify
so we want when a user goes to this
error route
we want to send them a message so we're
going to send back a python dictionary
now we can do just one file here we can
wrap everything here in jsonify
so we're going to change the function
name that handles this so they don't
collide so we're gonna have
say hello so we're gonna have say hello
on there
and now if you go back to application
and now we go to the error route
you can start we get json being sent
sent back to us so one thing here that i
want to point out is so by default
flask is going to format this into json
even when we don't use jsonify
so even if we take this one away so let
me take this one away again
and come back over here to slash hello
you can see that it works the same
so the python dictionary is directly
mapped to a json object
and we don't really have to to do any
other extra
serialization for this so that's gonna
be it for the setup if you're on windows
and you get any issues
be sure to check that be sure to check
the description i will leave some tips
in there
also check the comments because i'm sure
some guys are gonna be
laying down how things should be done
hey welcome back guys so in this one
we're gonna be talking about quite a
number of things
one is we're going to work on our folder
structure making sure
make sure we are structuring things very
well and then we are going to see an
alternative way to set up an
app by using factory functions and also
we are going to be taking a look at the
flask
f and how to manage environment
variables so over here what we did was
we created an instance of our app by
just setting it to flask
and then we are using this app almost
everywhere so we could go ahead here and
we connect our app to like a database
and all that stuff
but that approach will have some
drawbacks because that way we might not
be able to
easily test our application what we're
going to do now is we're going to set it
up
in a way that it can accept different
configurations depending on how it is
being run
so over here i'm going to start by
creating a few files and folders
so the first thing i'm going to do is
i'm going to create an src folder
so the src folder will host all our
application code so all the code we
write will go in the src folder
so over here i'm going to move this up
of course now to the src because now
all application code will be here and
then over here i'm going to create some
other folders
one is going to be the config folder so
the config folder will host all the void
upgrade configuration
for the different modules we are going
to be working with so also i'm going to
create another folder here
called constants so inside here we can
have some constants for example some
variables that we don't want them
so we don't want to change across our
apps for example the status quo so i'm
just going to create here status codes
dots by file already so
i'm actually going to prefix it with
http
just so we don't confuse that and then
the other folder i'm going to create
here is the static and the templates
folder
so this we can use them if you wanted to
like a web page maybe
a welcome page it would need us to have
like some css so we'll put the thing
here
let me also have some templates so in
the templates we can have some html if
we needed to
so also i'm going to create a services
folder
so in the services let's say we wanted
to send an email to the user when they
sign up
we could have like an email service
inside there
so one thing i'm going to do is outside
the src i'm going to create a tests
folder so i'm going to have tests
there so if we wanted to write some unit
tests or some other types of tests
we'll put them in there and now in the
source this is where we're going to
create our
factory function the one that is going
to set up our app
so over here i'm going to create a data
init file
so this is the file you can think of
this as the default file
so whenever importing from source we
don't have to put data in it every time
we import from source
this is going to be imported
automatically so over here we're going
to have a function that's going to be
responsible to create our app set up
some configurations and then return it
to us
depending on how we intend to call that
function so this function is going to be
called create app now this function is
going to be taking in a config
now the common two cases that i find
when writing apps is when you have to
configure it for
for testing or when you want to to use
it
as a user so over here when we call it
you're going to be passing it a test
config
so i'm going to set it to none by
default so over here now we can create
our app that just like the way we did it
in app
so let's import this actually let's just
import all this
because we're going to need to do the
same thing i always have to have all my
inputs on top although with python you
can have them anyway
so we're gonna have app equals
flask and then i'm gonna pass in another
argument here
and that argument is gonna be instance
relative config
so instance relative config and then
we're going to set that one to true
and that just tells us that we might
have some configurations that are going
to be defined in some files outside here
so now that we have that then we can go
ahead and check if we are running in
testing or if we have some testing
config
we can say if this thing is none we can
go ahead and configure our app now one
thing i'm going to configure quickly is
the secret screen
so over here we can do app dot config
then we want to do from mapping so when
we do from mapping then we can pass in
our configurations
so for now i'm going to set the secret
key so i'm going to do secret key
and then i'm going to set that one to
dev for now and then later i'm going to
be showing you how to use environment
variables to
pull this one in if we wanted to like
set up a database or maybe configure our
app to use
our app to work with another module
we'll be doing that in the
in this block but if the test config is
defined
then we are going to go ahead and have
an lcn and then we are going to be
running our app using that configuration
so you can do upload config that from
mapping
and then we can use the one that we
passed in when we created our app we
need to return our app so we can
return up like this now in the app.py
since we have
these functions of ours right now we
have another instance of our app so
we're going to clear this one away
and to keep things working over here in
our app we're going to have this
defined so let's push them in here
so we can have that index and this and
the add error
and now we need to tell flask to now use
this file as our main app entry point so
i'm going to stop the server and run
export class app and then we can so now
we are going to set our new path which
is in
src so you can do flask app equals src
and now if we run back our app first run
you can see that our server is still
on and when we come over here because
that we still have our hello world
and we can still go back to slash along
and get the message so which is good one
thing you must have noticed is i have to
update flask in the terminal by setting
the path to the flask up again
what happens is whenever we want to run
let's say first run in another terminal
now let's say i wanted to run this app
in a new terminal so i'm going to go to
a new one a fresh one
so if we do flask run over here it
doesn't locate the flask application so
instead of us having to go ahead
repeating this setting the flask app
setting the environment every time we
have a new terminal session
what we can do is we can create a
special file called dot flask m
so in the flat scan file then we can
have all our configurations the one we
are setting from the terminal
so let's see the environment so export
flask f equals development
let's also set the first app so export
flask underscore app
and this is going to be src and now if
we come back to a new terminal session
in fact i'm going to create a new one
and now if we do flask run you'll notice
that they tell us that there is a dot f
or a first game file and for frost to be
able to work with this new file we need
to have python.nb installed
so i'm going to copy this command here
and run that
in our environment just so we can get it
installed
so it's going to go ahead and install
that so when it's done and we run back
our flask
notice that now our application starts
and it picks up the config
so it's now using development and we
don't have to actually go ahead and
set these ones again every time we are
rerunning it in a new terminal session
so that's how you do that one thing i
want to say about the flat scan file
is that uh that flask m5 is not a
replacement for a dot m file so in the
flask m file we can have some
configurations that we might be free to
even push the version control now also
we might have some files that we might
not want to push the version control
and those we can put them in a dot env
file so i'm going to create the tnv file
so here i'm going to have export secret
key
and we're going to talk more about
secret keys in a few
and now here where we set up our
application with the secret key
instead of us using this hard coded one
i'm going to use a noise module to read
from
the the current.env so i'm going to
import os here so import os
and over here then we can set this one
to
os dot inf environ
then we can do get then we can get the
key
so our key is secret key so we can make
sure that
we are getting that secret key so that's
how you get started with
application factory functions and also
how to work with
environment variables so if the video
helps you out be sure to give it a
thumbs up
don't forget to subscribe i'll talk to
you in the next video
thanks for watching bye
hey guys welcome back so in this one
we're going to go ahead and start
modularizing our project
by using blueprint so with blueprints
we're going to be able to create
different modules that then we can
register with our main first
app so we can keep our application
modular
one thing you have to keep in mind is
blueprints are meant to group
related functionality together so you
don't have to
have like a blueprint for users and then
the users you're doing like
a product list so you always want to
make sure that each blueprint is
is containing code that is related to
each other
so instead of us having these routes
here these were for testing i'm going to
get rid of them
so to get started creating our first
blueprint we are going to have a user's
blueprint and also the bookmarks
blueprint so in the source i'm going to
create a
an auth dot by
and also the bookmarks py file now to
define a blueprint we are going to need
blueprint so from flask
import blueprint okay
so to create our own we're going to call
our own auth and then
you want to call blueprint and then when
you call this notice that we can pass in
some config
and the one that is very obvious is the
name so we can do name
so we can do actually we can do name
equals author we can just pass it in
since it's positional so let's pass
let's call this one both and then we
need to tell it where it is being run
from so we can do that by passing down
the name
and then we can pass other configuration
for example notice that on our api
for us to hit the endpoints that are
going to be in auth we are going to be
doing like our our app search api
slash v1 slash auth so we can specify
a url prefix so here we can have
something like slash api
search v1 and now once we define a
blueprint then we can have
routes on it so if you wanted to handle
like a register or a signup request
would have at off
then we can handle the post and then for
this
then we can we can detect when a user is
going to register
and then we can handle that like this so
let's have function register
and then over here we can return
something like
user created and then of course we're
going to be coming back here
to make sure we can put there's some
meaningful logic
let's also have a function that gets the
current login user for it it's going to
be a gate so you can have
it get so you can have like slash main
then we can have a function to under
that we're gonna have like me you can
return
user you can turn there like user
name okay so we want to now create
the same thing this should be registered
we're going to now create a blueprint
for
bookmarks so you can go to our bookmarks
with py and have the same thing
so we're going to change off to
bookmarks almost everywhere
so we can change this one to bookmarks
so what we're doing
are getting the blueprint just so we can
create a blueprint and then we are
creating a bookmarks blueprint
then we are prefixing all the urls to
just start with api v1
bookmarks and then over here we can just
do slash register and that is going to
be appended here so we don't have to
repeat this part
more than once so here let's just have
a get let's just
bookmarks get slash and then this should
return
and then let's call this one index
or we can call this one get or let's
just return an empty list
so and then we're going to be adding to
this later
so after you find your blueprints then
you want to register them on your app
instance so here before we here before
we return our app
let's go ahead and implement and import
our blueprints
so from those so from source
we're going to use and we are going to
use an
absolute import so we're going to do
import
this also imports bookmarks from source
bookmarks imports
bookmarks so over here to return the app
we can just do
app put register blueprint
and then we want to register the oauth
one and then we're going to have to
register the bookmarks one
okay so once we're done with this now we
can go back to our application so i'm
going to go to
the application over here and now if we
go to slash
api slash v1
slash me oh search
notice that we get our code from the
blueprint
being executed and now if we go to slash
difficult slash bookmarks the index
route
because that we get an error so let's
check why we have this error here
so in bookmarks we are just returning a
list so we can't return it like this
so what you can do is return as we
return a dictionary
with the key and the value so we can
have like bookmarks in here
and then we set that one to empty so if
we come back and refresh this you can
set now we get
the response being sent so that's how we
modulate our app
now there's more config you can sit here
so be sure to look up how to
to maybe do something with book with
blueprints if you have a special use
case
so i hope this was helpful if it was
consider giving the video a thumbs up
don't forget to subscribe i'll talk to
you in the next video
hey guys welcome back this time i'm able
to organize a application
using blueprints so in this video i'm
going to go ahead and set up a database
that's going to be able to contain our
data about users
and also bookmarks so we are going to be
using flask sql alchemy
which is an extension for flask that
adds support for sql alchemy
so simple alchemy facilitates connecting
python programs to
different databases and it can also be
used as an object
relational mapper which gives us a layer
of obstruction
when we are interacting with databases
from our applications
so we don't have to write like the grade
the details of the sql
so we can just focus on writing or
python code and move faster
so over here in our source i'm going to
create a file called database
ui now we need the first install first
flask simple arching
now to install this we want to run
people install flask simple alternate
so i'm going to stop my server on here
make sure you're still in your virtual
environment
and then run this installation command
so after it installs the first thing
you're going to need to do is to set up
our db
and then tell super arch me on how to
connect to it
so we're going to be using sqright which
is a file based relational database
so good thing with this is it comes
bundled with a python
already so we don't have to go through
the process of installing postgresql
and you will see that for the case we
are going to be doing here we can pretty
much do it with any kind of database
but be sure to not use a file based
database
when you're going to make a a big app or
the app you're going to put to
production so over here to get started
we want to import simple argument from
flask super archimedes so what we need
to do here is we need to create our tv
and then we set it to
sql and then once we create our db then
on the db we have
we have access to the model class that
enables us to define how our relation
should look like
so over here we can create a class so
this class we can call it user
so we're gonna now define our how our
user relation is gonna be
or our user table so we're gonna inherit
from tp
dot motor okay so down in here now we
can define our columns
so for the columns you're going to of
course have an id so that would be like
the
unique identifier for each user so here
we can say db.column
so for the user we want the user to be
so we want the id to be an integer
for example one two three four five so
here you can do
db dot integer and then we are going to
set primary key equals true
and this is going to enable sql argument
to restrict this to only contain unique
values
also it's going to also since it's an id
it's going to be assigned
automatically by incrementing by
incrementing the id of the previous
object
it's going to be managed behind the
scenes for us then the next thing we're
going to have is the username
so over here let's just say username so
the username is going to be
a string so we can we have string
and then inside here we can define how
long we want it to be take the maximum
number
so let's have so let's have our
usernames to be
less than 80 so it's not going to be
primary but it's going to be unique
so we don't want our users to have the
same usernames
so next thing we're going to have to
define is the email
so we also have to specify that this
shouldn't be now
we don't want to create a user without a
name so we can specify inaudible because
false okay
so let's also specify the email
so i'm going to change this one to email
so it's going to be a string yes
now an email might be longer but let's
just take our hours to 120 it should be
unique
it also shouldn't be narrable it's also
defined the user's password
so for the password it can be a string
we also have another type for text so
that allows you to store strings without
having to limit them
so for the password of course you don't
want it to be unique
because you're going to be actually
hashing it as you'll see we won't be
storing it as a
like print text so let's also go ahead
and define the creator that it's very
important we
get to know when this was created so for
the type it's going to be a date time
field
we want every time a user is created we
want to enter this
automatically using the current date at
that time
using the current date at that moment
so over here we can also specify a
default
and then we can set this one to
datetime.now so i'm going to import the
time up here
import datetime then we can set this one
to
datetime dots now okay
so we'll also have the updated ad so i'm
going to duplicate this
so this is going to keep track of when
this item will just update it
so updated that will be the date time
but here we can satisfy on update
and then on updates we'll also be
inserting in time at that point so one
thing that we'll most likely want to do
is create a single representation a
string representation of our model class
so over here i'm going to have it under
reference method so for this one we're
going to be returning itself
the username so to make this one look
better i'm going to use f strings here
so i'm just going to do this then here
i'm going to have user now we have this
then for the dynamic variable you can
put it in this
curry brackets so this is how the class
would look now we are going to be adding
there some
other relationships but let's first go
and define our relation for the
bookmarks
so we're also going to have a class
called bookmark now you notice that
still we are naming our model classes
we are just using like singular terms
just like other python classes
these are no exception they have to
follow the standard convention
of naming classes that's why we name it
as a single entity
so now let's go ahead and define how our
bookmarks will be
so first off we're going to have a 19 so
the id is going to look similar to this
i'm just going to bring this one in then
the next thing you're going to have is a
the body of a bookmark so someone can
have some
some details so buddy you can just get
the text
so let's make it malleable so if a user
doesn't provide it
they app shouldn't complain let's also
pick the url
that is very important to us that is
what makes our application
work so for the url we will keep a text
and we want it to always be there we are
going to need to have a way of getting a
short version
a short url version of our main url
so that is something we're going to be
adding within our application so the
user won't have to supply it but for the
constraints here we're going to use a
string
and for this it's going to be a maximum
of three characters
so when we generate it we are going to
always make sure it is three and before
we insert it here
another thing we are going to define is
the visits
so we are also going to have to track
how many times a bookmark was checked
out
so for the visits you can have db
program
it's going to be an integer let's set
the default so default
it's going to be 0. now let's have they
updated it and created that so they are
going to be the same so i'm going to
copy these and also bring them
yeah so let's now talk a bit about
relationships
and how we can create a relationship
between a user and a bookmark
such that querying our records becomes
more efficient so what we're going to do
here on a bookmark we're also going to
specify
a user id and then this is going to be
an integer field so let's see here we
can do
db.integer we will also specify that
it's going to be a foreign key so the db
the foreign key
now when you do db dot foreign then you
can specify the table
that you're referencing in here and the
column so since we are
since we are referencing this class here
we can go ahead and specify that we are
referencing user then we can specify
that this
user id will be matched with a specific
column on this
class so that's going to be the id the
id column
so on here you can do a dot id now the
next thing you're going to do is on the
user class
we're also going to define a
relationship with the bookmarks
so over here i'm going to have a
bookmarks
so for the bookmarks we're going to set
that onto db
with relationship so for the
relationship then we can specify
the class that we are creating this
relationship with
that's going to be the bookmark one and
then over here i'm going to say a
keyword called backref
then i'm going to set that one to user
now this keyword here
is just another way for defining a
reverse relationship
so this way we don't have to come on
here and we specify that there is
another relationship
and this is going to take care of us
being able to do
bookmarks bookmark producer
so just the same way we'll be able to do
user.bookmarks we can
this allows us to now also be able to do
bookmark dots
then they what we specify here
so now that we have that out of the way
let's also have a reaper method
for our bookmark so we have a
a reaper then we just have bookmark
you can just return anything here let's
just get the id
or the url that looks better so one
thing we're going to need here is we're
going to need a way
of creating a short url from a url that
is given to us
now whenever an object is being created
or when our class is being instantiated
the constructor gets called so over here
we're going to overwrite
data in it now we're going to be taking
in self and all the other
keyword arguments now over here we are
going to find a way of assigning
a short url when this object is being
created so here
we're going to do self dot strategy
so i'm gonna have a function called
generate show to you a rare
it could even be the redshirt characters
because in essence we're actually
getting the character
so i'm gonna change this one to shoot
characters so let's create this
now since we are in a class we're going
to have to call it using self
so we'll have def generate short
characters
so text itself just so it can access all
these other members
so thinking about how we are going to do
it we are going to find a way of getting
all the possible
characters and picking random three from
those possible characters
and the ones we we pick we need to make
sure that we have not picked them
before so first off we need to get our
numbers from zero to nine
now we can get numbers by using the
string class
so over here let me put string so import
string
so if i go down here now to get numbers
from zero to
nine with characters equals string
then on the screen we call digits this
is gonna give us
zero one two up to nine and then what i
want us to do is also add all our
alphabet
alphabet letters from a to z so we can
get all the alphabet letters by using
the
by calling string dot sk
letters on this very notes i'm going to
introduce you to the first share so with
flask you can just run flask share
and that's gonna take you to like a
python share
but in here you can go ahead and you
import everything in your app you
interact with it as if
as if it's a real first cap being run
so that's why so i'm going to import
string just so it's how that works
so if we do string dot digits
you see we get 0 to 9 and now if we do
string
dots escalators so just just
to ascertains you can see we have a to z
and then we have the version where the
the letters are
and then we have the versions where the
letters are kissed now for us to pick
random derivatives from this
what we're gonna do is here we're gonna
import random so
and then we're gonna be using choice
from random to pick them
so down here i'm going to have pictures
we'll set that one to random
but choices so if we do random those
choices then we can give it
like where we want to pick from so we
want to pick from characters
and then we can pass another key for the
weights so this
so the key specifies how many we want to
pick from there
now we can do we want we can say we want
to pick three
so if i did this if i came here and put
it random so if i put random down here
and then i did random
road choices and then pass the
let's just pass the the letters asking
the escalators so i'm gonna pass them in
there
so let's pass k equals 3
so when we do that you notice that it
gives us a new list
now what we want is to turn this now
what we want is a way to turn this into
a string and
not a list so we can do that by using
change so we joined by
an empty string so we can do empty
string dot chain
and then we can go ahead and change this
so i'm going to copy all this
and paste it in there and run this
and now you can start to get our strings
in a string format
so that's what we're going to do here so
over here i'm going to do this script
chain
then we're going to join this so that's
going to give us our three strings
now something we're going to need to do
this should be big
now something you're going to need to do
is make sure that this don't exist
already in advance otherwise
otherwise our link tracking may not work
well over here we're going to have a
link that exists so we're going to do
link but we're going to set this one to
self and then we can access query when
we're on a model
so self dot query and then we can do
filter
by so here we want to filter by this
short url
so before we insert the structure we
want to make sure it's not there
so you can filter by short url equals
short because depict characters
then we want to call first on it it's
going to return for us a varied bookmark
or it's going to return none if none
exists so here you can check if we have
the link so if you have the link then we
want to try getting another one
then otherwise our strategy will equal
to the characters we just picked
so over here we can have an else and
then we just return
this so if it exists we are going to try
to find it again
and again until we get one that doesn't
exist
so over here we can just record the same
function function so we're going to do
so without
generation cases and then it's going to
retry
until it gets a unique one so now that
we are done with this
we are pretty much done so one thing we
are going to need to do
is specify a uri that we can give to
simple argument so it can connect to it
so i'm going to go here in our first
game now i'm going to the first game
because working with
those things it brings some issues on
windows so i want to keep things
in here but be sure to change your
database uri to a file you don't want it
to
to get so over here i'm going to have
export
sql and then i'm going to set that one
to a local sqlite path
and then we will put three slashes and
then we are going to have one called
bookmarks
dot db so once we define this then we
can grow in our app so we're gonna go to
uh
create then we're gonna go to a factory
function
so here where we define the app config
from then we can go ahead and specify
the sql archime url then we're gonna set
that one to
os put environment
go to get this so we named ours as a
as sql archimede db uri that's the one i
want to make sure we have here
so one thing i've noticed is we named
our columns using a small letter
now this should be a capsulate another
small letter so let's go ahead and fix
that before we go any further
so i'm going to select every every
occurrence
then i'm going to make sure that this is
the captus and now the last thing we're
going to need to do is register our dp
with our app
so we are going to import our db so so
from src
to database import db
so down here before we register our
programs then we can go ahead and run db
dot db dot app
equals app and then we want to do
db dot init up
then we specify our app just like this
and now once we're done with this
we can go ahead and set up our tables or
set up our database to start working or
accepting
connections here i'm going to go back to
the first shell so the first
shell and in here we can import our db
so we can do
from src database
import dp so with db
now we can call create all
and when we do that and we do a db again
you can see that now
this has created a path inside our
rest api source folder and it's called
bookmarks.tv
so this is how you create the box by
running create all
now if you ever wanted to destroy all
your tables you can just do that by
doing
db dots
drop or like this but we want to create
them so we will run
create all and make sure that things are
good and now when we come back to our
folder structure you can see that over
here we have a bookmarks.tp
so if you have a sqlite explorer you can
go ahead and you see our columns
but now this is where it is and this is
where it's going to live for now
so that is going to do it for this video
so in the next video you're gonna start
working with like registering the user
and also to login users and all that fun
stuff so
thanks guys for watching if this one
helped you out give it a thumbs up don't
forget to subscribe
i'll talk to you in the next video
hey guys welcome back so in this one
we're going to be talking about http
status codes
and how we can set them up on our
application now first to understand what
http server scores are
it's basically a standard way for
servers to communicate
to the client of what happened on the
server
now as much as we can be able to on the
server let's
send back a message like yeah something
was created on the server or hey
something was deleted that is something
that
we humans can understand but grants and
servers communicate to each other
by looking at which data spots the
server returned
so for example here i'm on instagram.com
and i've filtered all my requests to
only return the xhr requests
so you can see here that the status for
all these requests was 200 meaning that
things were fine
now we need to be able to tell which one
to send back to the client
depending on what exactly happened so
when i sign out you can see that now we
have some other status quotes here
and this was of course issued on the
facebook server
back to this screen so this client can
know what to do
so this is the twitter login page notice
that when i enter a username that
like doesn't exist and i click next they
go ahead and send us
a 400. now understanding this status
calls proper is very
is very important just so we can
understand how what clients would expect
and how they they would interpret these
errors so you see that it's in red
and there's a reason for that it's not
because the developer quoted it it's
because the
chrome client is built to interpret that
as an error so what i'm going to do is
in our application so i'm going to go
here in our app
so just go to constants so in constant
remember we set up this file here
and then i'm going to bring in these
status codes here so you can see that
they all start with http and then they
code now these codes are the ones that
the browser will interpret and that's
and they are the ones that we are
setting to the values here
so you know applications we are going to
be using the status quotes this as a
constant and then it's going to be
picking this by default
so these are the most common ones now
you can differentiate when to use this
we're going to send this
by looking at what you're doing now on a
server
if something we want to send back to the
clients is something informational so
you
want to use some of the status quo that
start with one if we want to notify that
something was successful
we want to use ones that start with two
for example here you can see that
if it's just a mere okay we just send
the 200
if something was saved we use a 201
so if there's nothing to send back to
the client we send it to all form
and the client will perceive this as
successes
so if you take a look at uh the
redirects one the ones that start with
the 300 so 300
so 301 302 and the like those ones will
represent that there was a redirect on
the server it might
be permanent so be sure to take a look
at the difference
with the naming here so we also have the
client so if the user
if there's like a validation error on
the client we would be using like a 400
if there's an issue on the server let's
say a server can't handle the alert
we would be extending back at 500. so
that's our introduction to status codes
now in the next one you're going to
start registering the user
so when a user has errors we will come
in here and we check if we want to send
them like pad request
or if the user if we're able to save the
user on the server that one means that
if source was created then we're going
to use it like this
so by the end of the series we'll
possibly have worked with most of these
so so that's gonna do it for now if this
one helped you be sure to give it a
thumbs up don't forget to subscribe
and i'll talk to you in the next video
hey guys welcome back so last time i'm
able to
set up our status quotes and now we know
where we're going to be picking the
status quotes
so in this one you're going to go ahead
and start registering a user if we go to
oauth.pi you see we have an endpoint to
handle that
hundred there is the user registration
so if we went to
our postman admit and so if we went to
our postman and then created a new
request
and then and then created a new request
so our new request will be a post
request
since our endpoint accepts a post and we
are going to be going to slash
api search v1
register and did a post request
we are not sending anything but we get
user created here but this is not real
this is not working with the db this is
not working uh
this is not checking the user's data so
what you're going to be doing
is sending things like username email
passwords
so when we get this in our in our
handler
we should be able to like create a an
encrypted password
we should be able to validate that the
email is valid that the email is not
taken
the username is is alphanumeric and all
that fun stuff so let's start here
now i'm going to close down this because
my screen is actually small
so we're going to start by importing a
few things to get
from what is this one called
so from work suck we do
the security import
check password hash generate password
hash
so generate password and take password
hash are going to be used to
encrypt the user's password when we save
it in a tv
just so people don't actually go in the
db and they see people's login
credentials
so now over here what we can do is we
can try to get
the data that the user is sending so we
need the username the email
and also the password so to get what is
sent in a post request we need to also
import requests from
flask so with with the request
we should be able to do json
and then here we can define the key that
we expect username to be sent in
so expect this one to come in in a
username
let's do the same thing for the email
and then the password so email
and then the password so we're going to
do some simple variations so we're going
to check if the length of the password
is less than six so it can be if it's
less than six
then it won't send back an error so send
back an error you're going to be using
the sonify
yes so let's get this sonified here so
send back json you're going to be using
just one file so let's get that so here
we can just return
the sonify and we can just say
password use to short
okay now like we said we always want to
send back a meaningful status code
now over here now this will be
an area that's can be solved by the user
so we can send
a bad request here so you can just do
http
400 requests and that's going to import
our status quote right here
now that we have this check we can do a
simple check for the username
and also for the for the username and
also for the password
so for the username we're going to check
that this app for numeric
have a simple check make sure that we
actually entering a varied name
so we just check the link so just check
the link of the username
and let's have all our names be
these three characters and above so we
can just have username
is too short and be sure to change these
messages if you dim
it if you have some data messages to use
so let's
so now let's check that the username is
alphanumeric
now we can check if a string is is
alphanumeric by calling
by calling dot is rna so we're going to
check if it's
rna so we're going to check if it's not
alphanumeric also you're going to check
if it has a space in there so we can
just do if
space in a username then you can tell
them username should be
alphanumeric also you can just tell them
also no spaces
and also now that you've validated the
username and also the password
let's go let's go let's also go ahead
and predict that the email they are
giving us is a varied email now we could
violate this using a regex
but i'm just going to save ourselves
time by installing a package called by
datas
so i'm going to do quick install
validators so as that installs then we
can come over here and report
quality data so if you have our data
then we can check that
we can use that validate image and say
if not validators
email then we can pass the email that we
want to validate so if the user's email
is not valid then we want to send them a
json response
and tell them that hey your email is not
valid so we're also going to check that
if the
image is valid it is not it doesn't
exist already in our db
since our restriction is precise that
our image should be unique so we can
check that by doing if
so we're going to import our model
actually because we're going to need to
query the db
so from source dots database
imports user all right so here we can
just create a query by doing
this user dot objects then we want to do
filter by so
filter by then one check if the email
equals this email then let's just do
that first
then we want to check if it's not none
so if it's not
none if it's not none that means that we
have one
at this one record that matches then we
can tell that we can tell the user that
this one already exists
so we can return json then we say email
is taken
we are going to do the same check for
the usernames because the username
should also be unique
now take note of the status code that we
can use here so if you go back to our
status codes
right here in the 400 level notice that
we also have one for the
for the conflict this means that a
similar resource already exists on our
server
so what you can do here is we can use
that instead
so we can just do http
409.
okay so let's do the same check for the
username i'm gonna come back over here
and just do the same check for the
design so we're gonna check for username
and if it exists we tell them hey it's
taken and we send them a conflict
response
so now that we have these checks in
place now we can go ahead and hash the
user's password
so we can have pwd hash
so this is going to be generate password
hash and then we just pass the password
we want to hash
so the one you're going to have of
course is the user's password so let's
pass password in there
now once we have the password hash then
we can try to save this
new user to our db so we can just have
we can say user equals
because user so when we instantiate it
we need to pass it
uh we need to pass it the values that
are going to save in our columns
so username is going to be the username
the password is going to be the host
version of the user's password
so pwd hash
then the email is going to be the user
schema so once you instantiate our class
then we want to add it to the db
so here let's import user understanding
for db
so down here then we can say db
good session good add and we want to add
user
also want to do db with session want to
call commit
just so our changes can be saved now
once we update our now once we update
our db then we can tell
the client so now we can take back the
clients that
we were able to save this user on our db
and maybe they can go ahead and login
so we can just return what you're going
to return to sonify
and in here we can just have like a
single message
so message so for the message you can
say user
created now we can also go ahead and
send back the user
so user will send back the username the
username is going to be the username
they gave us
also they send back the email and the
reason why we're sending back this
extra information is the clients might
need to maybe welcome the user by saying
welcome thanks for creating an account
so they can use this
this username that we confirmed on our
server just send a message like that
then the last thing we're going to need
to send here is the status code
and whenever we create the resource on
our server we want to send backup 201
so we can do http 201 created
so now if we run if we run back our
server so i'm going to do first run
notice how we get this warning here
about simple argument now i'm going to
suppress it here just like they are
suggesting
i'm going to suppress it by going to
our init and here where we configure our
app
we can pass the zipper to my uri
and also this so i'm gonna set that one
to not
i'm gonna set that to false just so it
stops yelling to us
so once you save that you can see that
it resets no warnings and now if you go
back to our postman
so i'm going to go to postman this is
the request endpoint
then i'm going to select json here now
when we select json then we can be able
to send our keys and values so we can
just do that
like username
so for the username i'm just gonna say
username
reset the password
so the password can be password then
let's also add an email so you can do
email
let's have email at app.com
and now if we made this request so if i
click send
oh notice that we get an error and the
reason why we're getting this error is
because we are doing
with objects so this should be dot
querying
so let's change that one to slash to
build query
so now if we try to do the same request
notice that we get our user created and
we get a 201
so so now if we try to save
to create the same user you see we get
the error image is taken
so if we change the email i'm going to
add another pin and try again
you see that we match the username is
taken so i'm going to change the
username but i'm going to make the
password short
so if we try to do this we said the
password is too short and we can't use
that
so let's just make sure our password is
good
so for the username i'm going to leave
some spaces and also add some
information marks
we try this is that the validation for
the username is also working good
now if we do
now if we leave only a space let's do
that you can say that it is still being
handled properly
so if you run this you can see that we
get another user being created
and yeah so that's gonna do it for now
that is how we register a user now in
the next one we're gonna be talking
about how to
use gear directory identification how
that whole token of the application
thing
works and uh how to set it up with our
app
and how to log in a user so thanks guys
for watching if you enjoyed the video
give it a thumbs up
don't forget to subscribe i'll talk to
you in the next one
in this one we are going to go ahead and
set up jwt authentication
and also log in our users and give them
access tokens and refresh tokens
now if you are new to token
authentication so when you're making a
risk api like we're doing here
it is intended to be consumed by
different types of clients
so we can have an app that may be the
chrome extension an android app an ios
app
a front-end app like a react app so
authenticating across all those
different types of clients
calls for a solution that is not session
based because by default
we can use sessions to track which user
is logged in when they log out
and what they can access but that would
not work if we are going to like have a
mobile app
so the approach that we take in that
scenario is to implement
token based authentication where
whenever a user has a correct login
on our server we give them a token that
they can use to make calls
so that we can identify which user it is
depending on the token that is being
sent to us
now previously the way we would
implement this is with great like
a token table where we have like a user
and their tokens
but most recently we have a new standard
called jw team
now jwt allows us to create these tokens
without having to maintain a database
table
for these tokens and their users now
generality does this by using encryption
techniques
that based on a secret key so with a
secret key we can be able to
encode user's information into a token
and then when that token comes back we
can decrypt it using a separate key
and then we can tell which user it is
without having to make a call to a
database
so to implement this we have different
libraries that implement this we can go
ahead and
implement it from scratch using the the
pi data regime module
which is an official way to interact
with generity from python
but that will call for a lot of work
so that means we have to to do almost
everything ourselves
so some packages have been developed in
response to making this process really
easy
and the one we are going to be using is
frustrating extended
so this allows us to almost do all the
use cases we might have like
working with refresh tokens revoking
tokens so we're going to be installing
this so i'm going to go to the
installation
and we are going to need to install we
are going to need to do prep install
first generation extended so i'm going
to go to our terminal
then i will stop the server and run
quick install this
so to set it up you're going to go to
our app because we're going to set it up
with our app
then we're going to go to generality
extended then we want to import
data retain manager so once we have the
data retain manager then the next thing
you're going to need to do
is come and set it up with our app so
over here we can just do jdwt manager
and then set it up with our app such
that when we return it so that when we
return it
it knows that data ready was configured
now
one thing i mentioned before was that
generality authentication base is on a
secret key to encrypt and decrypt
tokens so we're going to need a way to
tell it about our secret key i'm going
to go to our flask m file
so flask n so here you're going to have
export generated separate key so i'm
going to set it to secretly
and like i said and like i said for
for very crucial information like this
we want to put them in a dot
in but right now i'm putting them here
just so people on windows don't get the
same issues
but if you can put them in dot m be sure
to source in
the source dot mv in your terminal just
so it gets updated and picks it up
but for now this should work fine so
once we have this
in our init we also need to pass it so
out
so down here we can pass through the
retailer jada is accurately
and we'll set it to 4s varan
gets so we'll be getting generity
separately
like this so the value here can be
really anything
but you want to make sure it is is very
secured
so make sure it doesn't really leak to
version control and it should only be
known to your server
so once we have that now we can go ahead
and start to work with uh
logging in a user i'm going to go down
here and we
we will create another route to log in a
user so we're gonna
have update post so upload post will
detect when user is going to search
login
so when a user goes to slash login we're
going to try the function
under that so we'll have login but log
in a user we're going to first get the
email and
the password that they are sending us
now we can do that by doing email
it's going to be request json email
let's also get their password
so we can just do password so one thing
i want to do here is instead of us doing
this instead of us using this syntax
here we're just going to use a
get so gate allows us to specify a
fallback value
if the user didn't need to actually send
the email but in our case
since these are the keys so these are
the keys that our front end should send
and this user is handled by developers
we can still relay that this iphone is
going to be there
so here let's make sure so here let's
make sure we have a default variable
just so application doesn't crash so the
first thing we're going to check is if
the user with this image exists in our
tv
so we're going to have user equals user
dot query you know want to filter by
email
then we want to do email equals email
they don't want to be put first
so we can check if we have this user now
we can check their their password so we
can just have like this bus correct
so for the password remember our
password remember the password we have
in adb
is encrypted but the one the user is
giving us is
is in plain text so for us to be able to
match those two
we are going to use this function here
we imported called check password hash
so down here we can just do check
password hash
so check bus check password hash takes
in the hash so the hash is going to be
the user's password from tv so that is
going to be user
with password because in adb it is a
hash and we are going to be checking it
again is the password which is
now in this case is this password that
the user is keeping now
so now we can check if this password is
correct so we can do if
his password correct then that means
that the user's authentication that the
user's login was good
so we can create for them an access
token and also a refresh token
let me go here and import some utilities
so i'm going to do from first data read
extended import create access token
and also create refresh token now i'm
going to be talking
about the details of this as we go but
right now what we want to do is uh
here once the password is correct you
can just have like refresh
ecos create refresh token
so refresh token takes in an identity so
once you say identity you can think of
the identity as the user
so in this case we can just pass like
the user id so you can just press
user.id
let's also create the access token
so access the identity can still be the
user id
so once we have this so once we have
this we can now tell the client that hey
everything's going to work on that
server
the user is who he claims to be and you
can go ahead and maybe redirect them to
the homepage and show them their
stuff so here we can just return to
sonify
so in here we're going to be sending
back the user but
but now we're also going to be sending
the tokens in the user object
so you can pass the refresh and also the
access this also sent the
name so username
this is gonna be user.username
and also the email which is going to be
user.email
or rate so now
if so now if we didn't match any user
with this email
or if the password was wrong then we are
just going to be returning
wrong credentials so over here we will
be returning
jsonify wrong credentials i'm just going
to have an
error here and then we can say run
credentials
and then for the status code we're just
going to say and authorize it so we
didn't authorize the user
it's going to be 401 it's going to be
http
401 and authorized
okay so once we have this now we can go
ahead and test it out
if we did things correctly possibly
things should be working so let's run
first run again
so the server is back so we have an
issue here
uh oh we used updates this should be
okay let's rerun back the server
so we are back now if you go back to
postman
which is our testing client i'm going to
keep this one here but i'm going to
create another request
so this time we're going to be going to
slash login
and if we try to do the git request you
said this is not being handled
but we want to make a post request we
want to make sure that we are sending
json
so i'm going to select json on here and
then
this here we want an email and then a
password so i'm gonna use
email at app.com
then for the password i'm gonna use a
password here
so if i try to send this notice that we
get wrong credentials but if we use this
user we created here
so i'm going to use this user anymore
i'm going to use this email here
that we have and also the password so
for the email it's going to be this the
password
so for the email it's going to be this
the password is going to click password
because that's what it is even
here so now if we try to login
we try to login to send and yeah we have
our tokens and we can go ahead and
authenticate the user and give and with
these tokens they can be able to access
any other part of our application
that is that needs them to be logged in
so
if i come here where we are sending
these tokens so it actually derived the
status code here that's good we already
specify our status quo
just so it doesn't mess it up at any
time
so yeah that's how we're just a user
that's how we give them a refresh token
and an access token
so in the next video we are going to be
talking more about refresh tokens and
that's how to refresh access tokens
so thanks guys for watching if this one
helped you out give it a thumbs up
don't forget to subscribe i'll talk to
you next time
in this one we're going to be taking a
look at how we can protect specific
endpoints
to limit them to only people who have
tokens for example you see we have this
slash me endpoint and in this slashing
endpoint we should be able to send back
the current logged in user's information
depending on the token that they use
by the one thing i notice upfront is
create access token might not be
something we use
down here so yeah this should have been
great access token
so just a mistake i just saw so let's
continue
so from first data already extended we
also have a decorator called
jwt required so you're going to import
generality required and whenever you
want an endpoint to require
a user first authenticate so we're going
to do a database required
and then that's going to make sure that
and then that's going to make sure that
if a user tries to
come here we are going to tell them hey
you're not you're not using a token so
please first get it talking
for example now if i went to the browser
and went ahead to slash
to slash api v1 me
notice how we get missing authorization
header so without this a user would
still be able to access the route so if
i come back
you can set it works but with this the
user will have first authenticate
so let me bring up my post one again and
for us to authenticate i'm going to
create another request
let's say like here and this one of
course is going to be
going to me so to add a header if you go
to
our login so here in our login
if we try to make the same request get
the access token
this is what we want to send on all the
requests that need authentication
so here i can come to oath and go to
bear a token so this the type we use
here is vr token and i'll show you more
in the documentation
and now if we make this request notice
that now we're able to access
the notice that now we are able to
access the route so if this token is
malformed or it has been tampered with
you should be able to see that the token
was not correct
so yeah so for us to be able to get the
real user
so inside here we can use something
called get the awful identity
we are going to put something called get
data really identity so down here
i'm going to import pdb here so pdb is
the python debugger it enables us to
pause a program and then we can expect
some variables and functions
so i'm going to pause that and then when
i come here and try to make the same
request
you said it gets paused here but when
you do get it ready identity and call it
it gives us the user id that was encoded
using that token
so we could go over here and do let's
say user
equals get every identity so that's
going to give us the
that's going to give us the user id so
in fact i'm just gonna put it user again
then we can go ahead and now query our
tv get which user this one is so we can
do
user user dot query
we want to say filter by one filter by
id
and then we're going to filter where the
id is the user id
and then let's call first because that
should give us only one
so we can set this one to the user now
we can just return
now we can just return this you can just
have like the username
which should be user but username
and also the email which should be user
email uh yeah that's it
if you go back to postman and make the
same get request notice that to get the
user sent back to us
so let's make sure we are sending the
status code
and things should be good so that's how
you get the current login user
if you had like a profile model that had
like more information you would get them
here
and also something i should mention
probably is the application welcome with
here is pretty simple
but if you had like large amount of data
you literally might not want to be doing
like user.name you might just want to
release user
at glass without having to get the
attributes so you would be doing that by
looking at something like marshmallow or
other ways or creating
specific serialization classes that can
do that work for you
but for now this should be okay we
should be able to still do fine
so thanks guys for watching next in the
next one we are going to be
looking at how to create refresh tokens
if if this video was helpful give it a
thumbs up
don't forget subscribe i'll talk to you
in the next one
hey guys welcome back so in this one
we're going to go ahead and see how to
refresh your token
okay so whenever we log in a user we
give them two tokens the access and the
refresh
now the access we've already seen how it
can be used we can use it to access
protected endpoints like this
slash main since the access token grants
access to
resources on our server we always want
to make it short-lived
say that in any case that someone gets
access to it they still wouldn't use it
to access resources on our server
for a long time so just something to
mention here
you see how we have all these
configurations here now the one we set
was only the secret key but if you
wanted to set
anything else like any other any other
config to the
to the module be sure to check one of
these
so for example you can see access tokens
by default will
will take 15 minutes to expire but we
could change that if we wanted to
and the recommendation is to always make
it as less than this as possible
and then you can see that the refresh
tokens can be exactly so you can always
use this to refresh the
refresh token to refresh the access
tokens
so to now create an endpoint to refresh
the access tokens i'm going to go to
our code so over here
we will have another endpoint it's going
to be slash both
slash auth then dot we can have it dot a
post so i'm going to have a post here
now here we want to go to when a user
goes to slash token slash refresh
so let's create a function to handle
that
so refresh token user token one thing
here we want
the user to only access this endpoint by
giving us a refresh token
now for us to enforce that what they
give us here is a refresh token
we're also going to use a jwt required
this decorator here
on this very view but the difference
here is here we're going
to we are going to expect them to give
us a refresh
we want to x we are going to expect them
to give us a refresh token
so we're going to pass refresh equals
true so to handle this what we want is
to first get who the user is so we can
do identity
then when you do get get the identity
thing should give us the user id so now
we can create a new access token
so we can just say access token should
we create access token
and in this case we pass the identity
which should be our identity
and now that we have a new access token
then we can return to the user
you can just say return to sonify then
let's have the access token for the user
then it's going to be the new one we
just generated for them and i will send
back at 200 so http
100 okay if we come back to our postman
so if we do a post remember we need to
send the refresh token
so you can see that it goes right to
validate that we are not sending it
so in uh in oath you can choose we want
to use bearer token
and we can if we try to use this notice
that it fails this one is expired
so we need to be using a refresh token
that is valid so i'm going to log in
here
and that's going to give us a new
refresh token and now we can use this
under this endpoint we can go ahead and
use that and now when we click
send you can see we get a new access
token
and this new access token is associated
with the very same user
who logged in here so that is how we
refresh the tokens
so if you wanted to use a different
method for this it's just up to you you
can just create it
doesn't really matter since we are not
even posting anything
so that's how we refresh the user's
token so i'm going to be posting the
video here
if it helped you out give it a thumbs up
and forget to subscribe the next
video we are going to start working with
the bookmarks creating bookmarks
and retrieving bookmarks and all that
fun stuff
so one thing i want to show you guys is
another one that you can define an
endpoint
so you see how we've been doing
bookmarks.get bookmarks with posts
if we wanted to have an endpoint that
had those two http methods
we basically would do bookmarks.get all
the posts
like that and then we'll have a function
that can handle
any of these but you will see a lot of
source code that will be that will be
defined differently
like this so you will see bookmarks load
route somewhere
this was the standard way to to define a
route in the previous versions of flask
if we wanted to define an endpoint that
accepts both a get and a post method
we would be doing it like this so
as the second argument we can specify
methods
and that can be a list where we can
specify the methods that
this route will handle so in this case
we want to use the same endpoints to
post or create a link or a bookmark
also we're going to use one to get all
of them now here we can have a function
to handle that
bookmarks so in here if we wanted to
check which request method the user used
we can go here and import request from
frosk2
so down then we can check the request
method by checking if request
loads method then you can check if it's
get or post
so if it's supposed that means that the
user is going to be trying to create a
new link
on the server so what you can do is we
can now get the body
so body we can set that one to request
dots get json whether you can do json we
can do
get json and then with this you can do
it.get
and we we want to get the body so let's
also have a
a fallback just so because the body can
be nullable
so let's also get the url so the url of
course we're going to get it as url
we need to check if this url is valid
because that's a very crucial part of
our application
for everything to work the redirects the
url has has to be valid
so let's import validators so import
validators
now when we have validators we can check
if the url is valid so let's check if
notify data
dot url and let's pass our url
so if it's not a valid url then we want
to return an error so we can return
and then for the value we can say enter
a valid url like this
so let's go ahead and also send the
status code so this one is going to be
400. if the url is valid we're going to
check that this doesn't exist
in the database again because we don't
have repeated repeated urls
so we can just do a simple check so you
can do if so let's import bookmark
so from src dot
bookmarks bookmark so now
over here we can check if bookmark got
query
then we want to run filter by so we'll
filter by url
equals url so if this exists so let's do
first
so if this exists then once the user
that this already exists
so we can just come over here and we
return
a url already exists
and this is going to be a conflict so we
can do http
409
and uh yeah that's how we handle that so
if the url is valid and it doesn't exist
then we need to go ahead and we create
a new bookmark and save it to our
database so here i'm gonna do bookmark
so bookmark is gonna be bookmark
so instantiate our model class and then
we give it all the properties
so we need to set the url it's gonna be
our url
then we need to set the body it's going
to be our body
then the next thing we're going to need
to set is the user id
so for the user id this is going to be
the current login user
so user id is going to be the current
open user
so i'm going to do current user so to
get the current user
you know we have something called
getability identity
just go ahead and put that from uh from
first
generation extended so get generity
identity so to get the current user i'm
going to define here we're going to get
there is identity and that gives us the
id
and as we are still here let's go let's
go ahead and we protect this endpoint
so we make it accessible to any users
that are logged in so here we can put jw
to required
all right and that should go ahead and
and we need to
import it which is uh
there so here we have the current user
as the id now what we want is we want to
import the db
so input bookmark let's also get dp
but we need to commit our
changes so db session
dot add bookmark
so let's also do db session commit
just so changes can be persisted okay so
after we save to the db then we can
return to the user
and this time we want to
just sonify
and we want to be sending the newly
created object
so since our properties are not really
so many we can now send back the id
so whenever we create so whenever we
create we get an id
associated with this bookmark so we can
just do that
from document to tidy from bookmark to
tidying
then let's also go ahead and send back
the url then the short url
so the url you can just use bookmark
here
then the short url that should be like
the shortcode
so short here this is going to be
bookmark
on the model we called it short url so
we can do that
then the next thing we're gonna need to
get is the
the number of visits so for the visits
obviously we expect them to be zero
because
by default we set it to be zero but
let's get that one then let's also get
the
body bookmark dot body
let's get created that created that
let's get updated that
so updated that
like this our status code
this is this is a creation we can send a
201 to http
201 created now before we test it out i
want to
create the one to get all so
down here remember our route can handle
two
http methods now since we want to handle
the gate or
so you can have an else and for a news
and if it's not a post request you're
going to be sending back all the
bookmarks
that this user had created so to get all
the bookmarks created by this user
we are going to first make a query for
it so we're going to do bookmarks
it's going to be bookmark or query
with filter by we're going to write it
by the current logged in user so you can
use that underscore id it's going to be
equal to current user
so that's going to give us a bunch of
bookmark options
now when we have uh when we have
bookmark options
we need a way to say your eyes those
python objects into
some data content of our network by
default we can't really send the
bookmarks
so what we're going gonna do is here
we're gonna we're gonna create our own
python list and then for each of the
bookmarks we're gonna be adding them to
our
data then we're gonna be returning that
so here i'm gonna do
a for item
in bookmarks so for each of those we're
going to be adding it to the
data list so we're going to do
data.append
so we're going to be adding appending a
new object and it's going to look like
this
so instead of using book so instead of
using item we can use bookmark
and bookmarks and for each of these
we're going to be adding them to our
our data list and then that's what we
want to return because that is a python
list and we can resign it using jsonify
so you can do return personify you can
have a key as data
and then the value as data and then the
status code should be
the 200. so you can do http
200 okay so once we have this
everything is up and running we can test
it out
and later i'm going to be showing you
how to use destination like to paginate
just so we don't get
everything at once so now that we have
this we can go back to our postman
so inside postman i'm going to log in
here just so we have a new
and the reason why we are getting this
here is you see when we come
to how we defined our function we go we
called it bookmarks
and this function is conflicting with
the name that we give to our blueprints
so what we want is we want to change
this to
to something else i'm going to call it
handle bookmarks
and then we also need to change a
generality required we need to
instantiate it like this
so once we do that and we'll try to log
in here so when i log in you can set now
we get our access token
so i'm going to copy the access token
and i'm going to get another
url so for this url for this area we are
going to go to d1
bookmarks so if we try to make a request
to this it's going to say we need to
authenticate
so i'm going to go to my auth and then
choose jwt
choose bearer then use my token here so
when i send a request
let's actually get an empty list sent
back to the user but we get a 200.
now if you want to post to this so if
you want to create one we're going to go
to our body
so i'm going to select row here and then
i will choose json
so we need to send a url so for the url
so we need to send a url so for the url
i'm going to have a google url in there
so let's have so just have it google.com
so it's also have a button so for the
body it should be
double quotes for it to be very json
let's say
my site so let me change it slash images
just so i can show you something
so if we try to post this you'll notice
that we get an error
and the error we get the sky is because
we are not putting the slash
so we need to put a slash just so it can
be handled properly by our route
so if we put a slash there and submit
you can see that we get our url being
saved
and also we get a shortcut being
assigned to this
and later we're going to be seeing how
we can work with this shortcut to be
able to track how many visits we did to
this
url so now if we go back if we do a gate
again so if you do get request
you can see that now in our responses we
get
our urls being sent back to us if we
made the third one let's say this one
now goes to
bing dot com so let's post
this my bing sites
is sent because it gets created now if
we do a get request
you can see that now we get three items
being sent
to us so that's how we do a basic create
and read on our bookmarks table
so if the video helped you out be sure
to give it a thumbs up don't forget
subscribe
i'll talk to you in the next one
so now we are able to list all our
bookmarks whenever we make a get request
to slash bookmarks
so in this one we are going to go ahead
and implement pagination
on this list as being able to send a
thousand records at once over a network
will be costly in terms of the user's
data
so what we want is to be able to allow
the front end to request a specific
number of items and also on a specific
page so what we're going to do here
is uh just maximize this so right now
the way we are acquiring this is we are
doing
query by the current login user but also
what we want is we want to be able to
paginate now with reboot.net we are
going to need two things
one will be the page we want to get
records from another one will be there
would be the package count i'm going to
first get the page of the
of the records where we are trying to
get from the front end
so we can get that one from uggs so
we're gonna do request
dot ads then we want to do get page so
by default our page is going to be one
and then we are going to type it to an
int so we're gonna be type equals and
so if the user doesn't send the page who
just defaults to sending them
page one okay but if they send it then
that's gonna be the page we queried by
so now that we have the page let's also
get the per page
just so we know how to limit our query
so we can do part page it's gonna be
request
dot x then let's get per page so per
page the default is going to be 5
then let's also type it as an int so now
that we have this
on the query we made we can go and do
page in it so we can do betternet
so paginate takes in two things one will
be the page so you can do page because
it goes the page and also the per page
so per page we already have that
let's do a page so that's gonna keep
working the same but
now we also want to be telling the front
end that hey there are some other pages
that you might want to check out
so down here i'm going to have a
property called meta so i'm going to set
it to a dictionary now one of the things
that we're going to be sending back to
the front end
is the current page so we can just send
the page so to get the current page we
can get that from the bookmarks we can
do bookmarks
that's going to be page then the next
thing we're going to need to send is the
number of pages that
are there we can also send like the
total number of items
so that's going to give us like all of
them then something else that we might
work with is uh the previous number so
if you have on page 2 the previous
number would be 1.
so that is obvious to get even when
you're in the front end but let's go
ahead and send it for the user
so to get prev we preview number so get
the previous one we just do
preview so
for the next we can also send back the
next page
by doing next i'm going to call it next
page actually
also this can be privileged so we also
have some other properties like has next
or
has previous which i think we can also
send just so we can look at how they
how they work so as next so in the
bookmarks we have
has next we also have has prev
so has prev that's what we want to check
here
so let's go ahead and save this now now
that we have the meta we can go ahead
and when we send back our data
we can go ahead and send back the meta
so here we can send meta
so now if we go back to our postman and
we try to get this
you can see that our token has expired
so let's go ahead and refresh and create
a new and login again
in the in a real app you would have a
strategy to automatically refresh it
just so we don't ever get that token
expired message
so now let's go over here let's go over
here and change back the token to use a
varied one
and make a request you can start to get
this error that's pagination object is
not iterable
and there is no and the reason why we
are getting that error is whenever we
imagine it
so whenever we button it on our query we
get more things sent back to us
now the data itself or the bookmarks
themselves they are sent back to us
in an in a key called items
so it's and then these are the things so
these are the things like hasbro
pages page those ones are also in those
specific case
but the data is in bookmarks with items
so that's what we want to
so that's what we want to now loop
through so i'm going to come here and
now make the same request
and now you can see that we get data
being sent to us
so down here you can see that we have
the a new meta
property and it has all these details
for us
now i'm gonna go here and actually
create more just so we can test out the
pagination
so just allow me to quickly change this
and just have some more urls to work
with
okay so now we have more than more than
two pages so if you do a get request
again
you should be able to see that we get
only five cents back to us
and we can see that has next is strong
has previous is false
and we are still on page one but if we
wanted to request page two
so to request page two you can see here
in our code
we said that we can send the page so we
can send it as
as an argument so in postman
we can do a query and we send page
because they said 2
so when we say page equals 2 notice that
now we are
sent all the details that are on page 2
and you can see that now we have some
previous that we skipped
some previous items that we skipped so
if we requested paid three notice that
we have only
notice that we have only 11 items so
page three should only contain only one
item
if you go to page three you should be
able to see that
now you should be able to see that we
only have one item sent back to us
and if we wanted to adjust how many we
request we can just come and
add and put an ampersand then we save
per page
so by page let's say we want all of them
but now that means basically won't have
any
so if we do that you can see we get this
four or four
so if we request page one we should be
able to get all of them sent at once
so those are the basics of how to
paginate now thanks guys for watching if
you enjoyed the video give it a thumbs
up
don't forget to subscribe and i'll talk
to you in the next one
so now that we are done retrieving and
patinating our bookmarks
let's go ahead and create a page which
can retrieve a single
item so to create that page we're going
to keep in our
bookmarks blueprint so over here we're
going to have at
bookmarks
then we want to do good so to get one
we're going to be getting it by the id
so over here we can have hints
get the id this is going to be a dynamic
id part of the url
so over here is a function to handle
that
so let's say get bookmark
when we have specific variables that we
are passing through the requests
we want to also accept them in the
handle function
so inside here now we can use this id to
find that
item but first the first thing but first
we also need to make sure this endpoint
is protected
so to make it protected we're just going
to do generity required
here let's define the current user so
that's going to be getability identity
now we want to ensure that the user who
created this is the only one who can see
it
so we're going to make a query to a dp
so the db query is going to be
bookmark.query but filter by so we want
filter by user id
it's going to be the current user and
then we also we're going to try to find
this this bookmark by this id so we're
going to do id equals id
and since it's going to be one we want
to do first just so we get that very one
so if we don't get the bookmark so we
can do if not bookmark
[Applause]
so that would mean that it's the one
trying to request it is not that's very
user
it's not it's not the user who created
it so this didn't match
or they are giving us an id that we
actually don't have in adb
so if we don't have it so if not
bookmark
then we can tell them that hey not found
so we can return
jsonify then we can say
message and let's do item not found
so for this we can send back a 404 so we
have an http method for 404
it's not found so 404
not found that's the one we want to send
back but
otherwise if we have the bookmark then
we can go ahead and return it
so just like we did here we're going to
return something like this
so we will have written return the
sonify
so we'll be just modifying this
the id and all these other details so
then we send back at 200.
so http 200 okay just like this
so now if we go back here and try to get
on slash bookmarks slash one
notice that our token has expired so
let's go ahead and refresh it
or we get a new one so let me just get
this
then i'm gonna go here then in the earth
then i'm gonna change that now you can
set we get
that one but if we try to get one that
doesn't exist like this one
we get a note found and we get a 404
being sent
so that's how we retrieve one so in the
next section we are going to see how we
can
delete update delete or update
so thanks guys for watching if this
video helped you give it a thumbs up
don't forget to subscribe
i'll talk to you soon
so now let's go ahead and add ability to
edit
a bookmark that we've saved so we should
be able to change the details of the
body
or the url itself so to do that
it's actually going to look a lot like
the ad so we're going to have
a handler for that so on here we'll have
at bookmarks then we want to call dots
we use two common http methods
one is the boot another one is the
another one is the patch
so we want to target when a user is
going to
put on the height is making a put on the
id so we can also
handle the same thing for the patch so
we can just have
patch on there too so then we can handle
we can handle
edits bookmark so we also need to expect
the id to be sent we're also going to
need to first check if it exists
because we don't want to try to exchange
something that doesn't exist
let's make sure that the user is logged
in so we're just going to put a jwt
required
decorator so over here you can go ahead
and verify that the bookmark
exists already so if it exists then
we're gonna go ahead and we change it
so we're gonna we're going to get the
new the new body and the new url that
the user is sending to us
so if you go in our post you're going to
need to get these and also we're going
to validate the url
so i'm going to copy this very thing
so down here
we can now get the body that the user is
sending
and the url and then we'll predict that
the url
the new url is actually still still
valid
now once the url is valid then we can go
ahead and update it in the db
so since we've already found the
bookmark it's here to update it
we want to do bookmark dot url
we'll set it to the new url and then the
body
it's gonna be bookmark body
it's gonna be the new body
okay then after we do this then we want
to call db
with session dot commit
okay that's gonna make sure that our
database
syncs the change so
this is how we update so to test this
i'm gonna go to
our postman then i'm gonna get one
so when we get one now remember we need
to put to make a put so i'm gonna make a
put but i'm gonna change
so i'm gonna change the url from google
so i'm going to change it from google
to sites.google something like this
let me change the body to my google
site site so let's change this so now
so now if we do a put on this you notice
that we get and we get an
error that the function didn't return
properly that's because when we finished
committing
the session we didn't actually return a
response so we're going to be returning
a response
so just the same the same way we
returned when we created
so on creation we returned this and this
is the same thing we want to return
except that we want to return a new
except that now the
status will not be created but it will
be just it will just be okay
so we just return the sonify then this
is going to be http
okay
so if we try to change now again you can
set to get a new one
so you see the id is kept that it was
before
but the url is changed to a new one and
yeah so that's how we update if we made
a patch
so patch is usually used when we want to
update like
bits of these objects which i think
which should even be ideal for this kind
of thing
it will still work because our handler
handles both of them
just like this so yeah that's how we
that's how we update so in the next one
we're going to be seeing how to track
which links we've visited and the links
we have not visited
so thanks guys for watching if you
enjoyed it give it a thumbs up don't
forget to subscribe
i'll talk to you later
hey guys welcome back so let's go ahead
and see how we can delete
an item so by the end of the video we
should create an endpoint
we should take an id and then check if
the user who's trying to edit it is on
who created it
and then it's it deletes it from the db
so
to do that you're going to do something
that's similar to the gate so i'm
actually going to copy this over here
so down here i'm just going to duplicate
this
and now we are going to be doing a
delete request so we're going to do a
delete
and then we expect the user to give us
an id we want the user to use the
authentic
we want the user to be authenticated so
we just
have this decorator then we're going to
name rename this to
delete bookmark so we check who the user
is then we are going to first try to
check if the user is going to offer it
or who owns it so if they are not the
ones then we are going to tell them hey
we didn't find that
so otherwise we want to delete it so now
we can do it is using the tv so you can
do
db.session delete so we're going to be
deleting the bookmark
so we need to confirm that by doing
db.session
commit so
now that we finish deleting we need to
send back a we need to send back a
response
now for the delete we can send back a
message like hey we deleted something
but a lot of times you're going to see
that a lot of times this is going to be
implemented by sending a no content
status so here we can just return for
the content we just leave it empty
but then we send back a no content so we
can do http
204 no content like this so now
if we go here in our terminal and we'd
make a delete request so if we do a
delete
you can see that it was deleted and we
get a no content if we try to fetch it
again
you can see that it was not found and if
we make a
get request to all of them so now we
expect all of them to be
10 and not 20. all of them
down here we have 10 that means it was
deleted from the db
so thanks guys for watching if this one
helped you to give it a thumbs up don't
forget to subscribe
i'll talk to you later
last time also we can update one and
also we're able to view one
so in this one let's go ahead and we
start implementing link tracking
now the idea for link tracking is just
so we can just so we can track how many
times the user
who created this bookmark clicked on it
because the whole idea for the bookmarks
is to be able to check them out later
just so with this kind of feature
we can implement something like on the
front end to allow users to see which
links
they are least checked out what the ones
they have checked out more
so to be able to do that the logic we
are going to use is
notice how we have the short url so we
have this but
this but with this we know that we can
map it to the url so we are going to
have a route on our app that will
be accepting something like this so you
see here we have slash
5000 we are also going to have slash
something like this
so with this we can pick which so we
with this we can pick which url it is
and then we increment
so it's visits count so the way you're
going to do that not
notice that this is not under any any
any blueprint so we can as well put it
here in our app and we let it get
handled by our app so
down here we are going to have an app
then we want to do a get
so for this we want when a user goes to
the short url so i'm just going to play
this tutorial
this is going to be a placeholder for
whatever the user
enters there it could be something like
this it could be any other
any other of those three characters so
this have a function to handle that
so i'm going to call this one redirect
to uri and of course we need to accept
the short url in there
and what it's going to be doing is going
to be finding the bookmark and then it's
and then increasing its visits count so
let's import bookmarks on here so from
from database and put that let's also
input bookmark because we're going to
need to query the db
so on here we can just say bookmark it's
going to be
bookmark dot query
then we want to run filter by
so filter by so we'll filter by
so we'll filter by short area
and then we're going to check the one
that is go to this shotguard
now with this we can be able to call
first or forward for so in the previous
videos we saw we're doing first but here
you can do first of all for
whichever it comes in handy if you want
to there are an error so first or four
phone that's going to be able to afford
for error if we didn't find this
remember we need to handle every
direction we don't need to send back a
json like it wasn't found
so it's ideal to just throw an error
just so a user knows that
hey what i'm doing isn't working
so now that we have the bookmark we can
check if we have it so we just do if we
have the bookmark
then we can do bookmark.visits
so we're going to be increasing them so
we're going to be setting them to
bookmark go to visits
then we're going to add one on them so
once we do that then we need to
of course update by doing a session
commit
so db dot session
let's commit just like this now after we
update our database then we can go ahead
and
return and redirect so instead instead
of us returning the response here
we can return a redirect so from flask
we can also import redirect
so now here we can just return redirect
and we'll just redirect to the
url itself of this bookmark
so now we can just redirect to
bookmark.url
and yeah that should be able to work
this should be a placeholder
and not at the exact string so over here
we need to define it as a placeholder
like this
so now if we did the same request
you can see that it goes to the app and
it returns a redirect and it goes here
so now if we came and did a get request
for this
i'm gonna do a get
and the token is expired but let me go
ahead and get a new one
and we expect it to have updated the
visits count
because in this case we have actually
visited it
so i'm going to go here and change the
token
so if we do a get you can see that now
the visits are
one if we check it out again so i'm
gonna go here
so if we check it out again let me just
take this one again
and put it here okay and you can see
that now
if we do another get you guys that we've
checked it out
two times here
hey guys welcome back so now i want to
show you how we can gracefully
return json when we get errors like 404
so since this is a json on the api
it makes sense to just send json instead
of this html
so here in our app so in our app itself
over here we can have an error handler
so we can have app
we want to call error
handler so when you call error handler
you need to give it the code of the
error we want to handle or an exception
so that means that if you had a very
specific exception you want to be
sending
specific responses for you would add it
but for us you want to handle when a
user gets a
an http 404 not found and we are not
handling it
in that view in that view so if this is
the error that the app is running into
so just the same way we handle other
routes
we can define a function to handle this
so we will call this
handle for phone so we're just going to
be returning adjacent response so we're
just going to return the sonify
and then we're just going to say
obviously this is going to be throwing a
404
but since we are sending this one json
you can as well
explicitly define the type so it's going
to be for
form so whenever we create the handler
function we also need to pass the
exception
so i'm going to pass e here so that can
mean
anything now if we come back to our app
so i'm going to refresh here
i'm going to try to go to this endpoint
here so i'm going to refresh it
and now you can start to get json being
sent back to the user
so if we remove this
and we try to access this you can see
because that we get html so
if it's uh i just if it's a json on the
api
then it makes sense to you do something
like this
so we can also handle errors that come
from the server
so let's say the application is
collapsing for some reason so if 100
like
500 level errors so here we can just
handle server errors so http
500 nintendo server errors
then we can handle those similarly
by doing something went wrong please try
again
we are working on it
or something like that but whenever we
are doing something like this the intent
most of it mostly is not to
just tell the user this is happening of
course that is good
but we also would want to know that
these errors are happening in our
applications and we can find out
handling these
so the common case is to implement some
error reporting or error logging
so when an error like this happens we
send it to
like the admin of our app and the admin
can go ahead and check their looks and
can come and fix the area
that are generated into this air being
thrown
so if we come back here
so to test this obviously we need to
have an error in the application
so i'm going to go to the bookmarks and
let me see how to create an error
intentionally so for example on the
slash route
i'm just going to come in and say print
a
so we don't have a anywhere so this
should throw an application error
so if we go to api
slash it's gonna be api
slash bookmarks which is this one notice
so slash api slash bookmarks so right
now it is handling
so right now this is catching it but if
we remove something like this and we
come back here
make it go the same endpoint
so notice how the 500 error is not being
called by our android function
and the reason why this is the case is
because we are running into bug mode
but notice when i come here and show you
so notice how
notice when i come and change the flask
environment to production
so i'm going to go to a flask aim and
instead of us using development i'm just
going to change it to production just
for now
obviously we'll go into production we
need to change a lot of other things but
just to demonstrate the error
i'm going to stop that and run back the
server so the server is on
so we can still run this so now if i
refresh
you can see that we get something going
wrong and this
is now handling the the errors
so point note here is our handler for
the 500
will only work when we are running in
production
so these kinds of errors don't get
thrown to the user
hey guys welcome back so now we have
implemented link tracking
now let's go ahead and provide an
endpoint that can give us some
statistics
about how our links have been visited
so what we're going to do is here in our
bookmarks we're going to go down here
and we're going to have at bookmarks
when i have to get so i want to get when
a user goes to
stats and let's have a function it's
going to be
get stats so
for this one we basically are going to
be returning
a list and that list is going to be
containing a link
and how many times it was visited now
we're going to make a query
that will give us all the links for the
current login user
so we can do that by doing bookmark and
we want to do
query filter by so here let's
protect the endpoints make sure we have
the user so
that means we can get the current logged
user just as normal by doing get
generity identity
so here we can just do bookmark we can
do user id
this id should be the current user so if
you want all of them we can do dot on
or right and that's going to give us all
of them so now to get the links we're
just going to
loop over them and for each of them so
we're going to be getting the link stats
from each of these items and then we're
going to be adding it to our main
array so if for each of the items we're
going to create a
new a new link variable and that's going
to contain
a dictionary it's going to have visits
so for the visits we basically are going
to be checking link
dot visits now for the link the link
here is
gonna be item so let's also get the url
all right let's also send back the id
just so we need to work with it somehow
we can also send back our shorts
url so short so now that we have this we
can just append it to our data so we can
do data data
and we're going to be appending there
our new link and then outside the loop
then we can just return
just sonify then we can just do data
here then we can set that one to date
then we can just return
200 so http 200 okay save that let's
remove this and now if we go to our
postman
and try to go to slash bookmarks slash
stats
in the real world we need to refresh
that without having to tell the user
that it expires so we need to
we need to refresh it automatically for
the user so now
if i try that you can see that now we
get all our links sent back to us and
how many times
they were visited so that's how we
implement the start endpoint so in the
next one i'm going to be showing you how
to do some custom error and some error
handling
on our api as we are getting close to
winding up
hey guys welcome back so now we have
built all our endpoints
we have tested them out in postman now
what we are going to be doing is we are
going to go ahead and add documentation
for our api because yes we have built an
api we
have built our backend code but right
now it's only us that understands which
endpoints are on our server
and how they can be accessed so we need
a way to
tell other people about how our api is
what our api
is and how it is structured and how it
is it should be accessed
what parameters what urls we can expect
and we are going to be doing that by
describing it using
swagger so saga is just a set of tools
that can help us to describe and
document our api in a standard way
and that means that anyone who
understands the open api spec or the
swagger spec
can quickly understand what can quickly
read and understand what our api does
now i'm here on the swag io
specification
now i just scroll down to the things you
need to do to describe your api
so we need a way to define like what our
api is who is it for
if you have some terms of use we can
list those ones there
so we have to create something like this
so we can also define like a contact
object we should also have
have these uh compulsory or optional
fields like name uri and the email so
there's a license
we have the server object so we can
define like a base url
for our server so
yeah if you have multiple servers we
would specify something like this
so i'm going to scroll down just so you
can take a look at what else is
available so we also have the components
objects
this is mostly the things you're going
to be describing so how responses should
look how requests should look how the
requests should look
how how the headers should be what query
parameter
what query params should be there those
kinds of things so all this stuff
we are going to we are going to need to
create a document for
all these kinds of things now you notice
that
it's quite a lot here so to be able to
make a documentation for a flask app we
have different utilities that we can use
now depending on how you build your app
some of these tools can be able to
automatically pick up a documentation
but the way we are building our app we
are basically following a simple
a simple structure we are not using the
exteriorizers to handle our responses
so we're going to need to do some extra
setup notice that when you're using
first restful your documentation might
not look the same as you're going to
work to implement hours but later i'm
going to be
creating an api using fresh stressful
which is like an abstraction layer
and makes things more easy and much
better that these make things more easy
to work with
so right now for us to get started
documenting our own because either way
we need to
we need the word to tell the the whole
world
what our api is and how it can be
accessed we are going to be installing
this classical
and we are going to be manually
documenting our api
so first thing we're going to need to do
is to install it so i'm going to go to
the installation broke
so we need to install flask like this
setup tools we already have it
so here i'm going to stop the server
then we can install flask
flash gap okay they were so innovative
on the name
so once we installed flassica we need to
configure a few things
now here in our now here in our config
i'm going to create a file called saga
dot py so i'm going to bring in this
here and then we can go over it
so with flask we need to define a
template now you notice that
these are the things we are seeing in
the api spec
these are the things you are seeing here
in the specification
so here we need to define a template
where we can specify the info about our
api
so this is going to be standard you
don't really have to memorize all this
just need to know what they mean so
we're going to define a base path so we
don't want to be saying
it so we don't want to be our server api
v1 on every call
so we can define a base path and then
all the other urls
all the urls can be relative to this
so we also said that you can accept http
or https
so this part here is really important so
for the security definitions
there we defined that our api uses the
bearer type of authentication
and whenever a user and whenever a user
is making requests
the bare authentication with the type of
the api key and then we specify that
whenever a user is making a request
we need them to send us the
authorization in the header
understand and understands under
authorization of course it's going to be
the bearer type
and should be the jwt token okay so once
we define this outside the template
down here i'm going to bring in another
config
so for this config we basically define
like we basically define the initial
headers
now for the specs the api that we
generate here should be compatible
with other documentation tools so we
specify a route that we can use to get a
json version of our documentation which
we can move on to any other tool that
understands open api or swagger
and it should be able to work just fine
so then we define a static path
so this static path here is basically
used to generate the css to show on our
documentation
so don't mind much about that so we also
defined that we want to be using swagger
ui
so basically is foggy ui just lets us
visualize things
in a good one and we specify the default
route which is going to be at the home
page
so now from now every time we go to
homepage we should expect to see a
documentation
we need to configure this directly with
our app just so app can now understand
it
so what we need to do is
so what we need to do is in our data
init
so for that you're going to go here and
you put a few things from first gun
so we can do from flask
import paint
so we're gonna so we're gonna import
soda itself
we're also gonna import swan from so
swag from enables us to create a yaml
file where we can describe
our spec so once we import this we need
to go in that
in our config so over here you can also
pass a structure config
so swagger and then inside here we can
specify the title
so the title can be bookmarks api
and then we're going to specify the ui
version so the ui strategy ways have
brought now we can choose the one we
want to use i'm going to choose three
which is the current at the moment
so i suppose for ui version like that
let's create let's go ahead and from our
config import our swagger config
so from source.config
dot swagger imports
we need the template and also the other
server config we defined
so now down here before we return the
app
so i'm going to go here so right here we
can go ahead and
configure software so we're going to do
soccer and then we give it
the app so app is app then the next
thing i'm going to give it is our config
so for the config we'll just do config
serger config
and then we can pass the template so we
can do templates because the template we
defined in our config
so once we have this our setup will be
done now to start documenting
so we're going to start by documenting
this short url now
document this what we want is we want to
use the actuator
document attack from decorator you can
do a swipe from
and then we can specify the spec so in
our case we will need to specify the
path
to where our yaml file definition will
be
so here we are going to so here in our
web word i'm going to call it i'm going
to create a file called
docs and then inside docs i'm going to
have so i'm going to have each blueprint
and then inside you're going to be
putting the recommendations so let me
have both here
and let's start with login tiamo
so let's also create the one for
bookmarks i'm gonna do bookmarks
now there are some endpoints that are
not really in our apps for example this
one
so for this one what you can do is just
in the root
you can create a short url
but yammer since we are in the docs
folder should be able to work fine
and then inside here we can first define
what what it does
here you can say redirects to
so now here this is a yaml format so be
sure to make sure you're
you're consistent so want to define the
tags that this should have
now the tags are useful if you want to
group the urls in the documentation as
you'll see
so we can also specify parameters so
parameters
so for the parameters we can say okay
for someone to come here
we want first make sure that we want
first macro that's in the path
we have the short url and then we must
specify we can specify that this will be
required
so it can do required true with the ammo
true is not like a python true we use
the true like this
so also we can define like the responses
just so we can tell the people what they
can expect
so you can do responses and then we can
say that okay
when we get the three or two then that
means
then we can describe it so we can do
description
and guys everything here is uh
everything here is
down here but i'm just showing you like
a standard way you might do it
so you can see like here description and
all this stuff
so for the description then we can say
something like redirects
permanently also we can return a photo
form
and this can be thrown when the record
was not found or when the tag what that
should share was not
when that showed url was not found in
rdp okay
so this looks good to me i'm gonna go
ahead and save this file again
and then we run back our flask app so we
do flask
run so we need to change
our let me change our config to use
development again so i'm going to go to
our first game
and change this one to development
stop our server run it again so we need
to specify the swag here
now here we're gonna provide the path so
we're gonna do
dot slash docs slash short
just to make sure we we have a varied
path and now if you come back here and
refresh
it's still failing let's take a look at
why though we are defining our responses
we need to make sure that this is behind
so we have responses oh we need to have
this here yeah so you want to make sure
your yamo is formatted properly okay so
now we just need to make sure that our
things are correct
so we have this simple description we
have the tags
we have this we have our responses
we have our responses which should look
good so i'm gonna go back to the server
and now you can see that it works
without an error and yeah
and we have the the and we have the
the documentation for the slash shutter
route and we have even a way to try it
so the authorized button is when we
specify that we are using the br token
in this folder config
now what i want to do here is instead of
me going and doing things
scratch these dmo files are prone to me
making errors
so i'm going to show you how you can add
like the one for looking
so just a sec i'm gonna bring it in so
to make like the one for logging the one
that makes a post request
i'm going to bring in this and then over
here
you can see that we start we have a
simple description
then we have the tags so the tags are
used to group these endpoints
inside like this so you can see that the
shutter is grouped under
max so you can see that now we define
the parameters then for the name we say
okay in the body
we expect some things so we require a
username and a password
and then we give an example of how it
should look
and we can show some example responses
now you just need to make sure that your
your your yaml file is formatted
properly
and these keys are the ones that you
should expect so now
to add this to our route we can go to
for oauth and then where we have login
so we have login we can have swag from
so let's import sock from from classic
so from trust gun
so where we have the login
you can have swag from you can have that
sort from
and then we'll define the path so our
path here is going to be docs
slash auth slash
login.tml so let's save that
and now if we come back here and refresh
you can set we have the authentication
added and
because of the tags that it is grouped
the urls are grouped along
but if i went ahead to let's say here in
uh so let's say here in the login if i
went ahead and change this one to
bookmarks
and saved and refreshed here
you're gonna see that now everything is
under bookmarks so that's what tags are
they basically allow you to separate and
group related endpoints together
so let me also bring in the registration
it should be
quite similar to the login so here
i'm going to have register
with yama so it can be yammer like this
or yammer like this
so now it should be the same thing just
that here we expect three things
and they're all required we have an
example in there and the example
responses
so let's save that now we need to of
course add it to this
we need to have the swag from decorator
so i'm going to copy this
and uh here you can also have it
and this should be register but yeah
and uh if you come over here and refresh
you can see that register is also added
now i'm going to add
i'm going to add some few ones for the
bookmarks then i'm going to leave you
guys to add the other ones because the
format now you guys have the format
so i'm going to go ahead and add one
that can allow us to get the stats
i'm going to create a folder called
stats a file called stats
demo like this and then it's going to be
bookmark stats we expect the user to be
authenticated so we say okay
the authorization header is required and
these are the sample responses
so you can either send back this or the
bookmarks themselves
so now if we go to our app if we go to
our
bookmarks we can have swag from
which we should import here we need to
be able to go to
our stats and also add this work from
so here we can have a swag
from we'll find the path
blocks bookmarks stats
and if we save this so if we take a look
here you can see that it
is tagged under bookmarks and also let's
make it yammer
just so we have all our files are
consistent
so let's rename it here
yama let's save here
let's try again now you can see that it
is added it's added here
and things are good whenever we define a
documentation like this
it's going to have a spec now like we
said now we are basing on the open api
is spec
sometimes it's called swagger effect so
this is one that can be
understood by even other documentation
tools now if you look here we have the
api spec.json
so with this we can be able to export
this documentation into other tools
so i'm going to go to postman here and
with postman you see you can have
in the file you can have the imports
option so the import you can import this
documentation using our link
so we need to go to slash apispace.json
but we that is just a relative to our
domain so we are going to go to our app
and then enter the spec url and then we
can click continue
and this is going to detect that oh this
is a valid documentation
then we can import it in as a
documentation i'm going to click ok
and when i do that we get an api and the
correction imported
then i'm going to close here and when
this refreshes you can set now we have
the bookmarks api
and yeah so down here if you click on
this
we should be able to see the
documentation so the more we add
more docs more more endpoints on here
the more we can get more when we export
so for the collection if i click on
correction we have this
new bookmark set we have this new
bookmarks
api and this can be used to
to test out apis really fast
so that is the basics of how we can
document our simple api
now i'm looking forward to creating more
tutorials that we use
that will use flash restful and we're
going to be seeing how we can work with
that
first restful and the api documentation
so if this
video helps you please give it a thumbs
up don't forget to subscribe
i'll see you in the next one where we
are going to be
i'll travel something other channel yeah
where we're going to be
deploying this application to the live
server so thanks guys for watching
hey guys welcome to the last video in
the series so in this one we are going
to be deploying our flask application
to heroku that way we can share a url to
other developers and they can build apps
for our api
so to get started we are going to need
to first change a few things
one is we are going to need a git
repository so heroku uses git to manage
deploys
so you want to make sure you're using
git for local version control
and in our case you're going to be using
github so make sure you have a github
account that you can
push your code to so i'm going to be
showing you a process on how we can do
that
now here in my terminal this is our
project
and to redirect we have uh the data init
py file
so that is where our application lives
we have the create
app factory function so to get started
i'm going to stop the server here
now the first thing we're going to need
to do is we're going to need to first
get a server that will serve our
application
on heroku so in our case we are going to
be using g unicorn
so i'm going to install it quickly here
by doing clip install
g unicorn and that's gonna go ahead and
install it
so now we have that so with heroku we
can be able to customize
how it runs our applications through
using a file code profile
so in the root of our projects i'm going
to specify a file called brocfire
now you can see that that has the hero
button there so what we need to change
here is we need to specify
the command that's going to run our
application now since we've installed g
unicorn we're going to be
you're going to be making it run our
application so do your unicorn
so you you type junicon and then you
type your path
to your application so
our path for now is uh data in it
so what i want to do is here in uh is
here
in our root i'm going to create a file
called runner.py
and this is going to be meant for just
deployment
so here we can import our app okay so
here you can define app
application equals create app then
you're gonna instantiate it
because that is that is how it gets
assigned to
the app one around so we wanna run this
application now
with unicorn and you can do that by
specifying a path
so in our case it's going to be in uh
source
dot runner then the application so we
can specify that by doing src
runner full current then the name of our
main application is called application
test this one out so i'm going to copy
this command
and inside the terminal here i'm going
to paste it
so this is how hierarchy is going to run
this notice that when i paste the
command here the exact command that we
want heroku to run
we get a server started and by default
it's going to start on the default http
port
so in our case we can see that when we
run this
we get a gene code running and then we
get this link here
so when i click this you can see that it
has the same version as our development
server now of course when you're
deploying you want to
also take care of some things for
example if you had a db you want to
connect to one production you would do
that but in our case we're just going to
keep our
secret db since we already have it so
we're gonna commit it to kid and
we just keep it working like that but
you have to have uh
like a database setup if you're using
something else like mysql
or postgre so now that we have this the
next thing i'm gonna need to do is to
tell
eroku which dependencies our application
needs so i'm going to stop the server
now since we're using pip we can use
feedfreeze
to create a file that has our
dependencies so that's why we're going
to create requirements.txt
so if we do this we get through gram and
cxt file
created and it has all our project
dependencies
so now that we are done with that then
we can create a git repository
for our project now since we don't have
any git repositories in
initiated locally yet we're going to
start by creating it on github
because you're going to need to push to
github so over here i'm going to
click new repository i'm going to query
our application
bookmarker api
so once we have that then i'm just going
to create it it's going to be public
and this is where all this was good for
the series it's going to provide now
that you've created it i'm going to copy
these default commands they give me and
to make it quick i'm just gonna
put it here so that's gonna initialize a
git repository locally
and it's gonna push a default file which
is readme now so if i refresh on github
we should have the readme you can see we
have the readme
so the next thing i'm going to need to
do now is to actually push
our code but like i was saying we need
to first also change our environment
just so we can change that we're running
we are now running to in production so
what we're going to do here is the first
app
we shouldn't mind it everything here is
going to be used for
for development our run-up process is
going to be running our app differently
since we set it up to use g unicorn so
we can keep this and then in heroku i'm
going to show you how you can add them
dynamically
so over here now we are going to get
checkout
i'm going to create another branch for
the one of this i want this to come
through a pull request
so i'm going to call this one deploy
app then we can add the changes so bit
add
everything so before we add everything
we have a dot envy file
and we don't have a git ignore file so
i'm gonna go online here
to dot git ignore
so this helps us to quickly create git
ignore files for
for the common technologies so if i put
in flask
and click create and see that we get
like a general dedicated notifier
so let me create it here it's ignorant
so i'm going to bring in all this now
let me remove this
so this should be able to hide our watch
environments
and everything that should be sensitive
so if we do a git status
we should be able to see that we have
all these files
now we need to remove our dot m this
main dot m that has things we shouldn't
commit
so over here we can remove it by doing
it rm
crashed dot env
because it gets removed so if you do a
git status again
uh you can see that it's gone so now we
can go ahead and add this change the
staging area and then commit
everything so git add the git ignore
and then let's ah and then let's commit
so git commit minus m
put a message
up so now we can do a push to github
so i'm gonna come over here
and use this setup stream just so
our subsequent pushes got this this
branch
so now i'm going to click on the create
a pull request link
and i'm just going to create it normally
you want to fill out all this just so
maybe
if you need to check something in the
future you can drag back and see okay
what was i thinking at this point in
time
so i'm just going to match it for now if
you get any issues we are going to
come back and actually resolve them so
now when we push to main
you can see that we have a requirements
file which europe is going to need
and also we have the we have the first
game
now for the first game we are going to
need to switch them in here so don't
worry about these ones being here
so now in heroku we can come here and
create a new app so i'm going to call
this one
how did you call it github let me check
just want to make sure it is the same
doesn't really matter just make sure you
have a name
and and if it's available then good for
you so i'm just going to say
rest at the end then i'm going to click
create app so when we create
app we can go to the deeper section we
want to click connect
github if you're not logged if you
hadn't authenticated before it's gonna
tell you to log in
so after you log in you're gonna have
your your accounts here
and then we want to search for the one
who wants to deploy to
so when i type in bookmarker api you can
see that it comes through
and then i can click connect so when i
click connect it's going to go and run
now it gets the branches then we are
going to go ahead and
deploy this branch so i'm going to go
ahead and click the pro branch
and then it's going to go ahead and now
start installing the things it needs
so it's going to detect that we are
running python and then it's going to go
ahead and
start installing things in the premise
txt so now that the deployment is done
we're going to see that the app was
successfully deployed
if we if we click on view it's going to
open up in a new tab
and right now you can see that we have a
title that we would want to see
so that means the application was able
to be deployed and it's being saved
so after that you're going to see that
now it gets ahead to be rendered here
now things are not going to be working
yet because we still need to do some
config
for example you see if i try to make a
call you can see that we get this error
in fact i'm going to copy this and go to
postman
so in postman i'm going to make another
request it's going to be a post
so if we try to do this you can see that
we get a 500
and we actually don't get more errors
since now we are running in a production
environment
so what you need to do is actually set
up these environments
so the way heroku does it is for the
things we define in flask m
they try to look for them in their
environment inside our hero code so to
set the secret key
we need to have something that is really
sacred and
that can be added to guess so i'm gonna
go to
my terminal and then i'm going to use
this utility that is provided in the
first website
so what it does is basically input os
and then it uses os to give us
and then it gives us a 16 random string
that you can use so i'm just going to
copy the
this format here and then inside heroku
you want to go to
settings so when you go to settings then
you will see
configures so for this
then we need to set the keys so this is
going to be
secret underscore okay
here the other things we need to set
and the sequel argument url
so go back to heroku let's add this
so let's set the secret to the dp url
it's going to be the same
because we can use the same if you're
using something like mysql or postgres
you're going to have your own
db url in fact if you're using postgres
heroku kind of gives you the
db url directly even when you're debris
for the first time
that's the one you want to put here so
let's go ahead and
also add our url
so let's also add a jwt secret
so copy this so for this secret it can
be anything
so this time we are not going to
generate 16 just generate eight
so we get this uh we just copy any parts
any substring is okay
just have something to work with and now
when we save this
and we go back to our postman so since
they don't give us a lot of information
i'm going to go to the body and send
like real data so i'm going to click row
then i need to choose json
[Music]
so then in here now we can send the
username
so let's have username as username
let's have the password
as the password as the username doesn't
matter
and for the email it's going to have
something that is invalid
so if i try to send this notice that we
get email is not valid
and this signifies that our api is
actually working so i'm going to go
ahead and
make a valid email so gmail.com
send this username is taken so let's use
username56 send this
now you can see user created so we're
just going to go to the login endpoint
just to make sure that we can log in and
you can set we can log in we get the
access token and the refresh token
meaning that our jwt secret key is being
picked up
so i'm going to pick this so i'm going
to go to a new url
and here i'm going to try to access the
i'm going to try to access the bookmarks
so those are on bookmarks
now we need to send our jwt that we put
on login
so i'm going to copy this here from
access
then the auth we want to pick bear a
token
then we want to send albert okay forget
the one that was revealed in mind
sometimes it gets preferred but just put
your new one so you can see that we get
our results being sent back to us
if we go to body and do a poster and
we need to post json of course so we
need to send the url and then the button
so let's try to send this so you get the
url is not valid
now i'm just going to pick a random url
on the internet so let me just
get a random one let me pick this here
so i'm going to go to postman
let's send a url yes me put
flask box
so if i go ahead and click send
because we get it's created now if we go
and do a gate again you can set we get
it listed so that means that our api is
even working even on prod
and also we have our short url so now if
i went to
our flask app if i went to a flask app
here slash this url and by the way if
you guys ever wondered how
url certain as work imagine imagine we
had a domain that was like abc.com
it would mean that we are able to
translate
in a url into less than seven
characters so imagine we had like
bookmarks api hero
app was like abc.com so that's how they
do it now
here if we try to get this we expect to
be taken to this
first config and that is what's
happening so our progression is up and
running
there might be some things that are not
working good so if you guys ever find an
issue be sure to
leave a comment and people are going to
be happy to take a look
so thanks guys for watching i hope this
was helpful if it was
give it a thumbs up don't forget to sub
i'll talk to you later
welcome back everybody in this video we
are going to go ahead and do it
okay its examine so we were able to set
up jungle we were also able to set up
possibly with our database so now we
have the jungle project running so next
we are going to start setting up static
assets which will include HTML which
will include CSS and JavaScript and also
bootstrap with our project so before we
get started if you're new here please
subscribe to the channel so you can
always get notified when I post new
videos let's just get into it so to get
started I'm going to go to my project
here let me zoom it in so you guys can
see so right here the first thing we are
going to need to first do is tell Django
where to look for our HTML files now the
way we do that is by going into the
settings that purifier and then we are
going to scroll to the section that has
some to install apps I'm looking for
template standard scope so we are going
to scroll to this place so here we have
this directory
let's call it template territories so
here we specify the directories in our
project what we would want jungle to
loot when it is doing but when it is
trying to render our HTML so what we are
going to do is right here in the project
I'm going to go ahead and create a
template folder so here our grated
folder called HTML not HTML but you can
literally call it anything so I'm going
to call it template because that's a
common convention so in here I'm going
to create an index dot HTML file just to
start up with so here right now we are
going to find a way of locating this
folder and the way we can easily locate
it is by using the iOS module so those
much basically I'll just access
operating system powers and forward
is Denis so to give us some hunting
methods one of them is path then we can
call path and go join on it so when you
go join up here jumbo has already like
stop reached mr. briefs where the
business fold of with the base directory
for project so we need to use that we do
a path join so that then the next
parameter will be the fire dafuq the
folder folder name that contains our
templates so quarry template so it's
gonna do it's going to look into root
root project folder and then it's going
to look into the templates folder next
so once now it looks he ain't going to
be able to be able to access all our
HTML so once that's done I see myself a
house crush but let me rerun it and we
are back so once that's done then we are
going to now tell jungle we have to look
for our static assets so to get started
I'm going to come over here and create a
folder called static static so in here
I'm going to create an it images folder
I'm going to create a CSS folder I'm
going to create what you guessed it's
JavaScript ok so let me go ahead and set
up our main files so should be main dot
CSS main dot J's so you will see how we
use this basically to test that it was
set up I'm going to add a console okiya
maybe just want to say on one just will
see - just to make sure that we have
like correctly set it up so what's next
so basically what's next now is to tell
Django where to discover these static
files so alia we were able to see how we
can discover
template
although haven't tested it but we will
get to that later
so now we need to tell it where to look
for the static files so the way we do
that is you go to your settings with
pure file still we are going to be
coming any coming in here often
so right here we need to add some more
information one will be the static files
directories so which we defined by this
constant static files underscore tells
so this is going to be an array so now
we are going to give it one cost of
course now we have only one folder that
we have created so now we will use the
voice module to get there so a good path
to join and of course you are going to
join by our base directory and then you
guessed it so let's first see what is
our static so you can see that our
static is in a folder called the
expenses website and then okay the
static is in its Messi's website folder
so now we need to do expenses website
slash what you guessed it static so yeah
so once that's done then one more thing
we are going to set up here is something
called a static route and this is going
to be useful when we are like deploying
to like a remote server which I will get
to show you later this is going to be
used by jungle when it runs a command
called correct stats it one of the ways
that jungle take menu minifides these
static assets will be unlike in
production mode so we need to also tell
it about how to handle that so you're
going to have to do static static we
have static URL so now we need to do
static route static route static
underscore route this one basically just
to always always do it but
[Music]
then to desta and then add static here
so when you run create static is going
to be to get all our static files and
then put them in a way that is highly
optimized and then created this folder
and put them there because I just take
details on the matter in production so
for now we have all this setup let's
check it for what is still running which
is still use so as this is setup now we
need to this have something to look at
so we close out here now if we were to
take I mentioned we are going to be
using bootstrap so it's good we start
from there so if you got good good rap
that coin and then we go to the example
section we should be able to see see
this dashboard section so this is the
starter template that we are going to be
going with so if you look here our like
final product had like a sidebar and
then they did are the main area so we
are going to do either to rake start out
from you so if I view the page sauce
here now I can like copy all this stuff
and then come back to the project so
here I'm going to need to set up like a
rapper a rapper template so this rapper
can contain the things that we'll have
on most of the pages so now I need
created five a fire code base code HTML
so in here I can posts all my findings
so we are going to start by removing any
things that we don't need so this one we
basically don't need it so first of all
right here we probably will need to
connect to it like linking static assets
so one of the things first things we do
is load the assets of how we learn
assets to your going to use this
templates IKEA or alert static we need
to load static this is because we are
going to need to link with our static
files here so I have that loaded then we
need to change this of course let's
change it to extinct actually I call it
Shree expenses so truly expenses this
would be the name we use so then we can
remove this so right here it's going to
be common that's on every page we go to
we somehow modify the title so I'm going
to also load a turn so this is the block
called title so I'll read it like that
then you may not need to even add it and
at the end whenever we we we extend from
this same plate then we can pass a
custom title so this can lead us past
the customs right when our now I child
templates so now just remove this all
this so also we don't need this so about
the bootstrap we basically need to link
to the bootstrap file so I provide to
the logo
so now I'm going to copy this out and
then I'm going to let's see
so this is gonna be assets and then it's
gonna block that then this should be in
ports so now here we need to create this
fire so bootstrap that means with CSS so
if you go to the static for the static
folder then in CSS you can create a new
fire and call it static bootstrap which
mean dot CSS okay so we'll get there now
I just want you to remove other things
these things are most importantly when
you are creating a progressive web app
but we don't need them here we'll just
focus on our jungle
stuff so please stay we the template
raising might need it so I will just
copy it out and I'll put it in Maine
there then of course I need to bring in
Maine and they will do that me copy this
out copy paste this is going to the main
let's see USS so remove that then we
don't need this integrity stuff because
we are copying and pasting anyway let's
say that's it you guys but we don't need
that then screen this one out let's
continue cleaning the dashboard CSS this
is ash saying custom styles for this
template so I also need to create that
fire and then we also need to get that
CSS so if we go to where we got the
template I think we can be able to find
it here so dashboard is here when you
click on it you able to get the CSS so
we copy it out we can replace it here ok
so this is this about the icons this
rooster the sideburn okay alright so we
need to also use it our assets index so
I need to use our assets syntax so just
you already read at the assets tab you
can do assets in CSS slash the fire okay
so here we change the company name so we
can call this through the expenses we
can keep the sign out for now and now
this is where it gets interesting so the
main area like I mentioned this is going
to act like a wrapper so you want the
common things to delayed out already so
now that we are sure that the navigation
will be the same now we need to pay
attention to this area so right now
notice that we have like in this main
show a luxury is not the main already ok
so here in this container food
notice that we have another sub nav and
this is the sidebar because you can see
that the the class is said back so I
want to move this one out into something
called a pusher so if I so basically if
you don't know what that means basically
it's just a part of a page that we can
always load in anyway so we are going to
move to move it into a partial that we
can like include on every page that we
want so here in templates I'm going to
create a folder called pushers and then
in here I'm going to create a file
called sidebar because it's an HTML file
so bring it in like that and of course
when you're when you're going to be
working with assets you need to first
loads load tag for for asset so you need
to do like load then static so once once
you have that then now you can put in
like the other HTML so we'll have this
one here now going back to our base we
need to include it so how do we include
other files in this HTML so we also have
another template tag called include to
include basically 16 if I we want to
include and the only ones include now is
using car shows which should be which
I'm templates so it's going to look in
templates and then that's why it's going
to look for the fire so it's going to
now Road pushers and we called it
sidebar
HTML now that we have that we are sure
that we have the navigation on top and
then now we have the sidebar so what's
going to be dynamic for the most part is
what would be in the main so in here I'm
going to select everything in the middle
everything until you reach the west main
and remove it because we are going to
new trait some custom things so here we
now need to make this section like
accept all the content that we give it
so how do we do that we use another
temperature called
liquid we use another block so
it's called content so in here in here
when you write this and you make a
template so an HTML file that extends
from this one everything you put in that
file will be everything when you put in
a blog content of that fire will come
and be replaced in here so we'll get to
that
so right here it's loading jQuery which
we want so also you see it's loading
charges which we also want we will not
be needing the J's file but we can take
this advantage to load in our main
chairs so to load in the Manges you guys
already know this but we use the stats
the assets tag so we need to do we need
to do assets then now you can use this
okay okay so you need to close here you
need one of them okay okay that's it / /
Cheers okay a DJ / alright so what we
are saying now is for on every page that
we render we want us to get access to
this file because the pages are
basically going to be wrapped in here so
this one I was called main actually she
can forget that okay so once we are done
here we need a way to actually test this
out so if you need to to jungle we are
going to create an app so what an app is
basically you can think of it as a
container for common functionality so
basically some people perceive an app to
be a complete application but in Django
we organize functionality according to
two apps so here we can think of like an
app that manages expenses and ad that
manages incomes and app that manages
authentication so you can look at it as
a container for common functionality so
it's great enough we have a sub command
codes that up so Python managed the
puree start up and I'm going to create
expenses actually a name leads wrangling
so I'm going to I'm going to rename it
so here I can rename it to expenses
although I might have to rename it
sometimes but we'll find out
so once you have the app you see it
comes out with the common files that
you're going to need to like write your
functionality so one of them is used up
UI so this is where you write all the
functions that that like render out what
the user sees will get there so the
tests that view I failed yeah you can
write unit tests for all the files in
this app the models that verify this is
I defined classes that took with the
database then in apps so this one is
more more for right configuration
purposes and basically to get there
so let me rename it to expenses so I
mentioned that it's for configuration
purposes and this is what Django uses to
manage the app under the hood so right
here now that we have created there we
need a way of telling junga about it so
such that it can be able to now start
connecting it to the database and all
that good stuff so how do we do that so
when you go to settings of profile of
our main project you're going to find a
section called apps so whenever you
create an app let's get there this is
where you register it so here you can
actually edit records and Django will
know where to find it
ok so once you have that now we need to
actually see something so how do you see
something so I mentioned that the views
that py is where we define all that
user-facing logic so I'm going to create
a function so so I'm going to call it
index and then it's going to take any
requests so so on the internet right now
we are making a sub
education meaning it's capable of taking
any requests and then sending back
responses so that's why we use this this
competition request and now this one can
be able to extend out responses or
understand what's coming in so right now
we see on our first line we are
inputting something called render and
basically this can be used to print out
an HTML page so let's see so now let's
make our index how our index function to
turn an HTML page so we are going to
turn random and here they show us the
trend that takes in your requests it
requests in a template name and in the
context so they request basically is
just like background information to give
it con take a context or where it's
coming from and what it contains so the
template name is we have already told
John Wood where to look for the
templates now we can come over here and
now say we want you to go in templates
and then we want you to use we want you
to use actually we don't need we don't
even eat it good the templates cause
it's early it already knows the area so
I wanted to go to impress and then find
expenses can you file called index.html
okay so the the context by default is
none we'll leave it to that but
basically that can be like extra
information you want to pass in okay
we'll get we get there so now that you
have this we need a way of connecting it
to our application so that the
application knows how to to route
requests to this to this app so again we
are going to create a fire code URLs py
and in here we are going to define like
our URL so basically what you are going
to be able to do here is be able to see
what is I do best info and then tell
Django to give it to them
actually let me just stop shouting and
continue so let's define this called
your buttons and in here we need to
refine parts and what and what reduce
and what view functions should be
executed on them so before I even write
I need to first input some cool stuff
yeah so from jungle rot URLs imports but
also I need input my views of course I
need still jungle to use them so from
notes input okay so the first part we
are going to do will be the home rock
this slash rod soap at five the default
one we want you to render use dot index
okay so also we can pass in a name here
so the name can be used to like match
back to to a route when you give Django
a name it can be able to return for you
take the road that's configured to that
name and that can be handy Moscow times
so let's give it let's give it a name so
expenses okay so now we have we have
defined like the path for this app but
now we need to like configure this to
our main URL to a main application
routing so if you come to this one in
the main app directory you're going to
find here actually it's the only thing
there so this is where we add all of our
wrote into the at our new apps so here
you can add like path and then you can
add erode so let's say we want to get
expenses you can a break expenses but
I'm going to keep it like home since we
have only one up and then we am going to
import another utility here put include
so this include can combine like all
URLs of an app let's say we have many
like if you think about education
evacuation route logging road you have
like a preferred route so if those are
in one up then you can like combine them
so I'm going to do the same thing using
this include so include then yeah you
can pass in a string so here you pass in
like the name of view of your app which
ours is expenses in the tools so this
now will merge two expenses up and the
URLs
put py file which now will return this
so that would mean that if we had if we
had now let's say we add something right
now like at that expense so I say we
have something like this we don't need
to go back to there the main application
routing to add it to actually Democrats
because they include now will include
everything actually I think it was named
very well so here I'm going to to create
another function so I'm going to call it
like and experience absolutely that
experience so now I need to put a comma
there then I integrate this function so
to create it and use it
py same thing it takes in request and
then for now we already know we can
return a template although we basically
can do a lot of things yeah but we will
cover all that's good stuff as we go on
so might a placement be called add
expense with HTML now let's great these
templates before we we forget about them
so in here I'm going to create a new
file but stromberg need to create a
folder so expenses such a dismissed HTML
in here the screens are vanished saying
the expense okay so is to close it
copy that then we need to have an
index.html file because that's why what
our home wrote will look for
so HTML let's say something like
homeless specificity expenses list okay
okay let me add some some bootstrap just
to know that our bootstrap is connected
or the help us debug beta if you get an
initial the class here for the list item
the class here will be risk group and
list item concern
both via both via then we need to close
it out of course then since this is bush
shrub we need to give it a dress so it
can stand out is to go fight him I
should be a class then I'm going to copy
this and make sure we can have something
to test with so once we have this I
noticed that I didn't quite bring in the
booster of fire
good thing I remember so let's give that
so to get it you there's a theme that we
can use if you go to get bootstrap but
then if you go to boot stretch so this
this website has like pre-made themes
for bootstrap so you can pick out like
something that you like a kind of design
that you like I'm going to pick up any
but you guys can look at it to see if if
you like themes and so they are quite
different from the original bootstrap so
here I'm going to repress what is here
which is not actually with our new boot
shot we are new bootstrap CSS and now
when we go back to our base HTML
mm-hm everything is good here but now
notice that everything we are going to
be rendering will be like rendering here
meaning we need a way to extend this we
need able to extend this file in our
child folks so so here before we say
like add expense we need to include this
one so great extents
so extend basically will take everything
that is in the other file which now ours
will be best at HTML and then we'll add
this one or two okay so that's well and
good
I'll copy it then repeat it for my
index.html okay save it and yeah so now
let's actually test it out to see what
we have now I will
and the project again run Java so we
have an error looks like we missed to
put a comma so if I go to my URLs at p1
yes astatine put a comma D now it's
running again if I render it you can see
that we have some errors but we will fix
him so this is saying I forgot to add
assets on slash so this is most - like
it will be so on the slash basically
render index so which index will render
index will render what we already know
this one question is importing from base
HTML meaning we need to check there so
in versus tml here we are looking static
then is to calculate the error ten nine
so we are bringing in assets it should
be static guys I'm sorry about that this
should be static I don't know how I even
forgot that so replace that with static
and now let's restart our server so
let's look at it now and yeah so you can
see that this is coming in so basically
what this is doing is it's rendering the
sidebar which is here but tomorrow or a
bootstrap is loaded so to check what
problems we could have we could inspect
the JavaScript console is ready to have
some good information so now we see our
JavaScript is loaded but bootstrap is
not so to find the bootstrap we need to
come over here so we are saying of the
static CSS push wrap main CSS okay I see
here we have a space so you can clear it
out hopefully that is the problem so
when you reload again everything is set
up we are able to see that our bootstrap
is is coming through our template is
clear set up our devil
is being loaded all right so I think
this is going to do it for the video in
the next one we are going to start
actually in the next one you're going to
start building out like the real hungry
real functionality so actually to show
you that our routing is working if I
come here we're going to add an
underscore expense socially not so it's
add dash expenses you can see that it's
also coming through so this is good for
now I'm going to be pausing the video
here if you're new please subscribe in
the channel so you can always catch up
with us whenever we have new stuff I'll
see you guys in the next video
hey guys welcome back so last time we're
able to fetch a list of campaigns from
our backend and we can display them here
on our front end and we used a method
called getstatic props
so like we said the reason why we used
getstatic props is we would want this to
be called at the bureau time such that
we can fetch all the data for this page
at bureau time now when we go to the
detail page we would want to do the same
thing so we would want this page to be
fetched at build time and the html
pre-rendered already with the data so
normally with this kind of detail
routing on the web we would have to
let's say come on this page when this
page has rendered pick the slag and then
make a call to get the data
but with the kind of approach we want we
want all the data to be fetched at build
time that approach will not work because
there won't be any user to click any
buttons
now next year supports us at being able
to achieve prerendering of all the
detailed pages for all our
items on this list by giving us an
implementation for a method called get
static paths so what git static path
does is it goes ahead and makes a call
to our server and then returns all the
slacks that are on the server and then
nextgs can use each of those slugs to
generate the individual pages for that
campaign
so to implement this you're going to go
to the slab now first you're going to
first implement the get static path
function and that should be the one that
returns for us all the slags on our
server that would want to
fetch data for and pre-render
so here we need to export
it has to be an async function so export
async function
it's you have to call it get static
like this so inside this function we're
going to go ahead and make the same call
we did here so we're going to make this
call here to fetch the data so what i'm
going to do is actually copy this and
bring it to
here because it's going to be the same
call but the difference is now we want
to only get these lugs we don't care
about the images everything because this
function should return the slugs which
will be a substitute for the page itself
so here we're going to fetch now when we
first we get the data so i'm going to do
a cons and also get static parts runs on
the server so here i'm going to log this
and i'm going to construct the data so
this is going to give us a list like
this so it's going to be an array with
each of these objects but what we want
is to only get the array of slugs
so the way we can do that is here since
this is going to be containing all of
these we're just going to strip out
everything we don't need and only use
the slag so we can use a map function
for that to manipulate the contents of a
an array so here let's have const all
slugs so this is gonna be the data
then we're gonna call map
so map gives us each item in a callback
function and we can now just return the
slug so for each of the items you're
only going to pick the the slug and map
gives us the array of all the objects
that gets enumerated from this map
function this should be able to give us
the slugs so something like
slug a
strike b
slug c
so now the return from the get static
path should follow a format that has a
params key and then the slag itself so
something like this so you should be
able to in get static path we should
able to return an array and that array
should contain objects like this and
each of those objects should have a key
code params
and
that's going to be
an object also and then in the object
there can be the slugs so something like
this so slag
is gonna be a slug now since we already
have the slugs what we can do is we can
still map over these
and inside each of these we embed there
the key for params and set the value to
the slug itself so here we can just have
return we're just going to do all slides
then we want a map so this is now going
to give us its lag so what we want to
return params for rams
and
the value is going to be the slug like
this okay so this is going to give us
now our parts
so what we need to return from the
function
will be the parts so we're going to say
comes these parts
so would be the parts so here we can
return an object that has path in them
and we can specify another property here
called fallback
so i'm going to say fallback equals
pose so right here we could be able to
apply false true and broken and the
difference between these options here
are that whenever you supply false nexus
is only going to update the data when
you rebuild again but you could be able
to supply but you could be able to
supply true or blocking and that would
enable nexus to create fallback pages
for when a user tries to access a
campaign that was not generated at
bureau time and also there is a feature
called incremental static site
generation but won't be getting much
into that so for now we will only expect
next years to work with the data that it
builds at real time and
not having to expect it to to prefetch
other pages that don't exist so let's
keep this now whenever we implement the
get static path
that means that nexus is going to know
about all our slabs and right now what
we need to do is we need to fetch data
for each of those parts last time we saw
that if we want fetch data at bureau
time we can implement get static props
and this is what we want to implement
now so i'm going to copy
get static props
and down here we will have get static
props and basically what happens is
whenever we're on a dynamic route or a
dynamic page like this next yes it's
going to check if we have get static
parts now when we have get static path
this function is going to be called for
each of those parts and the data is
going to be fetched for each of them and
whenever we have get static but each of
those path is available in the get
static props function and it's available
as a probe so we can get it here so the
path is is passed in here as params now
with this we can be able to access each
individual slug so you can here we can
be able to do params.slack and it's
going to be called for each of the items
that are returned in the path
so here we can now do a call to our
backend to this endpoint here for the
detail
and get this data and and
get static props will pass it to our
page and the page can get it as props so
let's go ahead and make a call so i'm
going to come here and make a call like
this so this time we are going to be
fetching the detail so we're going to be
using here params
dot slag since our path has the params
key and then the slug inside so it's
gonna be accessed like this and this is
gonna go ahead and make the
http call so we expect to get the data
here so you can say cost data equals
this
now we can return props like we said in
get static props we need to return props
like this
so we can return props
and for now we're just going to send the
data to our page
so now if we go to our page here we can
expect to get that data
and down here if we can select the data
we should be able to get it so if we go
to
our website
and refresh and open up the chrome
console
i'm actually going to minimize this and
go to the console so if you refresh you
can start to get the data being logged
inside here meaning that we're able to
fetch the data we're using these
functions here
if we open up our chrome console
and click on one of these so notice when
i click on one of these
we didn't go ahead to make a call to the
server we didn't so if you take a look
here you can see all the requests go to
post 3000 so the data is gotten and then
it's cached inside the underscore next
underscore data
but this is in development but this kind
of shows you that the data is going to
be prefetched and we're not going to be
making a calls to the server when we use
this approach
so now that we have the data we can go
ahead and display it in the ui so for
now we will show the image so i'm going
to go here so i'm just going to copy our
item so i'm going to copy the whole div
and bring it
in here so we'll go here we have
campaign we're gonna remove this expand
this
so we'll have the container then we will
have the
the description and the title so let's
remove one of these divs and save so now
the data is the object so here we were
using element we're going to change that
to use
data
and of course we don't want to route
here so we can remove that on click we
need to import styles
so for now i'm going to use the styles
that we were using for the for the home
and then in the next one we're going to
be starting the next page we are going
to be starting the detail page better
so now if you come back to the site i'm
going to refresh it
we need to import image from image link
just copy this
make sure we are inputting image image
image
so now
let's also import link we might have to
use it to go back
so let's get it down here save
come back
date format says import date format also
since we are formatting the data in the
detail let's come back here
and you can see that our data is being
displayed so this is how we set up the
ability to fetch data for dynamic routes
using get static past and also get
static props so that's gonna do it for
this one if it helps you give it a
thumbs up don't forget to subscribe and
i'll talk to you in the next video
hey what's up let's go ahead and
implement this show hide password toggle
on the login and the register
we have the password input but we want
the user to be able to see the password
if they want
especially now that we don't have a
confirmed password input this should be
able to do that so let's implement it
so let's start in the login now the only
thing we are going to be changing here
is
changing secure text entry to either
true or false
so if i came here and turned this to
false and we went
and typed something you notice that you
can see the password but when it's true
then it's gonna not be showing that
so what we'll do is we're gonna have
some inner state here to
keep track of what's happening so cost
is secure
entry
[Music]
then we need a function to change that
so when user clicks set
is secure entry then we can do use that
then it's going to be true by default
let's make sure we have used it being
imported properly
so now right here
this is going to depend on his secure
entry now here we can have our
attachable because we want the user to
be able to click
just have touchable opacity in there
then let's move that text also
inside up there so i'm going to copy
this
then bring it up here let's have
an on press on press so and press can be
it's just good
i have a function here so we'll be
setting
his secure entry
to the value so the current value will
be
you can get it in prev then since it's a
boolean we can just return the opposite
of that
brain so you can say notes prevaria
so that means that you can come here put
something you see it's
you say it's a password by default so
when you click here you notice that it
shows
when you click again it hides so now
let's change
what is shown here on the text right now
we are going to say if it is secure
entry
then we want to show
otherwise then we want to hide now you
see
this being shown we can hide you can't
show we can hide we can show
so let's duplicate the same thing for
the other side in the
register so we can come to the register
where we have the password let's remove
this
error here we are logging we shouldn't
keep it
so this is where remove this
let's also bring in our use state
the one we defined up here so i'm gonna
cut this one away
copy it and then bring it down
this side too and then make sure i'm
putting new state
so when we come here we can hide so also
when you come this side we should be
able to
show and hide okay so this was
quick and easy so i hope this video was
helpful if it was give it a thumbs up
don't forget subscribe and i'll talk to
you soon
hey guys welcome back so up to this
point so we can log-in a user and
actually get the access token so if I
log in here using my account should be
gmail.com let's say I've ok you can see
that we get our tokens you can get the
access token
and then we get the Refresh token but
when our token expires we don't have a
way to refresh it yet so what you're
going to do is you're going to set up an
endpoint that will be responsible to
refresh it and we actually going to use
one that's to end up view that's already
built into the simply WT module so right
here I'm gonna check copy this from the
documentation and then you know
authentication URLs dot py after the
e-mail verification I'm gonna bring this
one in so what it does is basically it's
looking out for checking out for you
when a user is trying to access token
slash refresh and then it's rendering
the token refresh view from a module all
rights of it of course we want the token
refresh view so you can get rid of this
so once we have this one set up and
we'll come back to the application
reload everything should be working fine
but now we should be having this
endpoint that takes the previous access
token and then return those a new one so
let's see so here if I come and supply
and login password is my username is my
email doesn't matter so when we login we
get the access token and a refresh token
so let's say this token this access
token had expired yeah so what we want
to do is actually be sure that we are
logged in so let's say we keep this
let's copy it and then make sure that
here we are logged in to Vera and then
the token so it's authorized it
so meaning that's now if they took a
never expires we can use the Refresh one
Taurus copy this now if we go to our
refresh you can see that we need to
provide a refresh token so I'm going to
bring this one in okay this should be in
strings so now if I click execute you'd
be able to get a new access token so now
we can replace our expert expert access
token with our new access token
so that will ensure that the user won't
be equal to mus Cairo goat when they
took logged out when their token expires
and they can keep a good experience
using a front-end grant application so
that's well and good so I'll stop the
video here if it helped you give it a
thumbs up consider subscribing to the
channel and I'll see you in the next
video bye
hey guys welcome to the last video in
the series so in this video
i'm going to be talking about one of the
libraries that has
made my life easy writing react native
apps and that is react native size
matters so as much as we use flexbox to
manage our layouts in react native that
really does well
in some aspects but it doesn't do well
when we want to scale
things like font sizes so depending on
the device
the size of your phones and other ui
widgets would not always look good
because every device is different every
device has different
density pixels so we need a way to
really adapt our fonts and all our
and the sizes of our widgets to this
screen that they are being rendered on
so when faced with problems like those
one of the first thing you're going to
be thinking of is to use
the dimensions that's built into react
native to create a user that you can use
in your app to manage the scale
depending on the size of the device
yeah so yes you could do that but it
would take you a lot of work
so i want to introduce you to this
library here react native size matters
so the way it works is
basically for every static value to like
width phase font sizes
paddings margins we can always wrap
those
inside these utilities so we have
utilities like scale vertical square
metal scale
most of the time you're going to be
using scale for example here we have
this image here
we're going to now apply a scale that it
now adapts to this kind of
to this very image that it's to this
very device that it's on
so let me go ahead and show you how you
can use this module so down here
i'm going to install it of course so i'm
going to do yan add react native size
matters
down here and then once it's done we
want to now be wrapping
these static values we are setting in
now in the
scaling utilities so i'm going to import
this scale here
okay so i'll give you an example here so
let's say we here we were specifying
font size so
font size let's say
21 let's have this you notice that it's
looking like this
but if you wrap this in scale scale
and save you see that now it scales to
the
to the device it's at so similarly for
this i'm going to come over here
and also add some padding on the top so
i'm gonna do padding
top then let me make it
five now so if i save you notice that we
get this padding here
but now if you wrap this in scale
so let's do that in scale you know that
it goes down a bit
and i can prove it when i can now i
and we can see it if this this is big so
if it's in scale you see it's that
and if we don't have scale on there you
see it goes back up
so this is one way you can use scale
when you're like writing in nine styles
but most of the times you're not going
to be writing in nine styles and you're
going to be writing
styles in your in your styles.js file
so the way you can now use this in your
style.js file is here
instead of us instead of us using the
stylesheets component from react native
we can use one called scaled
sheet so we can do that and then it's
going to import it from your native size
matters
now if we save this nothing will change
and that's because we have not really
applied
any the utilities to these values here
so over here if we want to scale this we
want to now wrap it in a string and then
we want to do at
s and save you see that the image now
scales
so now we can basically repress go ahead
and repress
everything or wherever we had the the
other scale
so over here i'm also going to do at s
for this and save so for these font
sizes
similarly we're going to do at s because
we want them to already scale to every
other device they are being rendered on
so if i save this you see that now that
increases let's do this padding too
at s okay
for the font size we'll do the same
at s let's do this padding
s for the form padding let's do the same
okay let's also scale this
all right let's do the scale here
change this myself
to be at s and save
and things are now looking like this so
these are the things that you may not
really notice
before you start to test your app on
different devices
but once you test your app on different
devices without you doing
uh this adjustments for how fonts would
look
you're going to be shocked and they're
going to be really sad
for you when you see how your app will
be looking
so this is one of the utilities that i
found very helpful
so for me now it's like the de facto
standard for every app i'm working on i
first set up
these and i use them everywhere so every
everywhere every component i make sure i
am putting in consideration
how the fonts and paddings and layouts
will scare
on every other device so i hope you
found this one helpful if you did
give it a thumbs up don't forget to
subscribe and i will talk to you soon
hey guys welcome back up to this point
we were able to come over here and make
a request of us to our back end
and we are able to get all these results
sent back to us
but whenever we are acquiring our
database we always want to make sure
that we are acquiring it in the most
efficient
way now one of the ways that we have to
be able to achieve that is to enable
pagination
on our back end so donation will allow
us to be able to
query a set of results and not retrieve
everything
at a time because if you think of it if
you go to an application like facebook
you want to be looking at everything at
once and we can implement some
imagination techniques
that will enable us show a user a set of
content
only when they need it or when they
are requesting to see it so now you can
see down here we have
up to they are quite many i believe they
are like 70.
so let's say we want to be able to fetch
a set of these at once
so what you want to do is i'm going to
go to the code here and what you want to
do is you want to go to settings on the
rest framework settings
and then you want to enable pagination
so what you can do here is you can set
up a default vagination class
so over here django provides three
classes that we can use to paginate
our apis one of them is the limit offset
pagination another one is the page
number detonation
and the third one is the cursor
pagination so
to enable the limit offset pagination
and i will talk a little bit more about
how it works
is over here you want to do rest
framework
dot imagination imagination dot limit
offset pagination
so after we define this we can come over
here and specify the limit
so the limit will represent the number
of items that are sent back to us so if
we say
limit equals one we have only one result
sent back to us and also you'll notice
that we have
more more metadata sent back to us so we
get to see how
many items are all are there all
together
we also get to see if we wanted to fetch
the next page what kind of request would
have to make
so also we could specify an offset so
the offset allows us to specify
a number of items that we would want to
omit when we are making the query so
over here i can come and say and
offset equals let's say 10. notice here
that the id that we had retrieved was
41 but if i say offset 10 you'll see
that it's going to go ahead and omit 10
and then return for us this so if we
turn this to 20
it's gonna now omit 20 and return to us
the first item after the offset so
basically that is what that means and
the reason why it is the ids are
decreasing when we increase the offset
is because our ids are based on uh
created that and we
we are ordering these items by the
latest
so that's why this is going down but
basically the way it works is offset
will allow you to specify where the
query should start from
so basically here the query starts after
20 items
so this can get quite expensive and it
gets low as the number of records
increases
because the database has to read up to
the offset number of rows to know where
it should start selecting the data
so this guy that is how the limit offset
works so
you specify the limit if i add a four
you see it returns four
but then it starts to select those four
after each it ignores the first 20
and then start selective the first form
after the
first 20 depending on your on how you're
ordering
okay so you can also use page number
pagination so over here i can just
instead of using limit offset vagination
i can use page number
donation and basically this allows us to
specify space
a page that we would want now whenever
you use the page number variation you
can also specify
the per page setting you can say
for every page which is page size
then you can specify the number of items
you want from the
from here so if you specify 12 and come
over here
i'm going to remove the this
queries for the limit offset and then
try to make the same request
you see that we still have a pagination
but now we have
a next page given to us so if we say we
can say
page equals two
so let's make sure it's correct so if we
request the page
three you see that we have a different
set of results
and they give us these pagination links
to go to the next and the previous pages
which is good now you might be asking
yourself how do we control the
specific number of records that are sent
to us and not having to rely
here because depending on the scenario
let's say one of our users is in the
mobile app
from which they have a smaller screen
and they don't need to view like fifth
items at a time
which you may want to allow on the web
application because
maybe a browser can process those
records faster and the user has a bigger
view area
you would want to be able to specify
let's say the count so you
something like the count because let's
say one
right now you can see it's not
respecting that but if we want to enable
something like that what we need to do
is we need to create
a custom a custom pagination class so
i'm going to go to our to-do's over
here and then create a custom class so
i'm going to have a
module called pertination you notice
here the way this class is implemented
it's
restaurant recognition the page number
pagination
so we kind of have to follow the same uh
the same conversion of how we name our
things
so over here we can set up our custom
class so we're gonna have a class
custom page number
origination so over here we're going to
have to inherit from pretty number four
nation so coordination with the number
pagination
let's import detonation so from rest
framework
import destination so now that we import
from here we can specify a few things
we can have the page size so we're gonna
have bed size
let's say one here we can also specify
the page size query per round
which will allow us to specify how many
we want on every page from the clients
so page size variable round
then let's set it to count so we can
also specify the maximum page map
the maximum page size so max page size
let's say five you want to specify the
maximum page size for
the reasons like you know when the front
end controls
what the server returns anyone who is
taken to enough would be able to control
the front end
to send a specific query to the back end
but if the back end has a specific
restriction on what the front end cannot
send
then it's going to be good and of course
you wouldn't want
someone to be forcing your server to be
sending a lot of records
so let's set this to five and also we
can
we can change you see how we have page
we can change this to something else if
we want it
and you can change that by specifying
the page query param so page
query param you can
just call it like p and save so whenever
we define a class now we can come to
the individual view we want to use it so
it can come let's say like over here
and we specify a pagination class
so let's set it to this let's import it
so from
reduced detonation and put this
and once you import this and come back
over here and try to make the same query
you see that it is now returning one
because we are specifying the count here
so note that it is not really
giving us the page if we used page as
pin
you'll see that it is gonna still work
so now it's giving us page three
and yeah we want it to request and we'll
do that
yeah so if we specify 10 notice that
it's not giving us the 10 it is now
using the
max it is now using the max page size to
restrict how many we can get
but if we change it to 15 and come back
over here and make a request
you can certainly get the 10 cents back
to us so that's going to do it for the
tutorial i hope
it helped out if you did give it a
thumbs up don't forget to subscribe
i'll see you in the next video
welcome back last time we're able to
register a user so we can come here
supply a username and a password
and we're able to validate if the
username is unique or the email is
unique
and when everything's successful we can
create the user account and we bring
them here
so in this video we're going to go ahead
and create the login form and also log
in a user
so what i'm going to do is here in the
login template i'm basically going to
repress this and then we'll walk over it
so what we are doing is we are so this
basically adds
things like semantic awaited title
and all that stuff so then because we
want to load an image here we load
static
then we have the blog content so i'm
actually going to move the blog content
in here so we have the blog content
so here we basically have a semantic
card
and then inside there we have the form
so the form
it has the the method of post meaning
you're going to making a post request
so it's good to always use the post
request for things like login
credentials
because you don't want to expose these
things in the browser url
so if you use the get they would get
exposed in the url but you don't want to
do that
so here we have a cross site request for
jury token so
down here we have the username field and
also the password field
now you will notice that the username
field has data
but username as the value so this one
here we need to be passing it in
so that's pretty much it it's a very
simple form so now we need to handle
when it is submitted so the action is
going to be
login and if you want to use this of
course you can take a look at it
you can copy it out or if you can
just look in the github ripper check for
the exact file
templates authentication login and you
can just copy it
okay so let's go ahead and create the
let's go to the view and see how to
handle the user login
so i'm gonna go to the authentication
views so that's gonna be here
we already have the login view
so what we wanna do now is to handle the
post request
so we do if request posts if request
dot method is post then we want to grab
the
username and then the password so we can
say username
let's also grab the password
okay like this so here what you can do
is uh for us not to worry more about the
validations i'm going to come to the
template
and make these fools required so here
you can add required
and here we can add required so the user
can't submit it without filling in the
details
so in the in the view what you can do
now
is we want to try to authenticate this
user so to authenticate the user we are
going to need some few utilities from
django
so i'm going to come back here and input
some
things so from django contrib
dot auth import
authenticate and also log in
okay so now that we have this over here
we're going to try to authenticate this
user so we're going to try by doing user
echoes we call authenticate
authenticate so authenticate takes in
the request and then the credentials we
want to
basically verify so here we pass the
request
and also we want to pass the username
and password so it's a username
equals the username and then the
password
equals the password so if this user
exists
it's going to give us back the user so
what you can do here
is we want to check if not
user so if there was no user if we
didn't find a match
then what we want to do is we want to
still redirect to this page and show a
message
so here we can see we can create a
message by saying messages
dot add message so it takes a request
then we want to pass the type so it's
going to be messages.here
error then the method is going to be
invalid
credentials okay so when we have that
error then we want of course to render
back our template
so here we can render back the template
now
if we have the user meaning if this was
able to authenticate
what we want to do is we want to call
login so login
takes texting the request we want to log
in so you can do requests and also
whenever you call login you pass the
request and also the user
so we want to pass the user that
authenticate gave us
okay so when everything is good now we
can maybe say welcome
the user who has logged in so we're
still going to use this
uh message so here we can say message
with that message
it's going to be a success so let's now
say
welcome i'm going to use an f string
here then we can say
welcome then we pass user
dot username once all this is done we
want to redirect to the home page
so we can say return redirect
so we'll be going to the homepage so
remember home
want to reverse need to import reverse
so now we are going to the to-do home so
that's going to be i believe the route
is called home
so if you come back here in the urls for
the
whether it's first input reverse so from
django
urls import reverse
so if you come back to the urls for to
do you see that the home has the name
home
so here if we say reverse
then home it's going to return for us
that url so
looking good so let's go ahead and see
what is there one thing you
you will remember for sure is whenever
the username
has an issue we are currently saying
please preserve it
so whenever we have an issue we want to
preserve the name so we want to
be sending this data in the context so
we can still go back to our view
and do something like we had done for
the on the login
so here we can create a context
context it's gonna be we have data in
there
it's gonna be requested first that we
use
user doesn't lose the data in the form
if they have an error
so now here when we are rendering it
we can pass the context again
which will have the data this one and
this one will contain
the request.post.username and so
in the template we can quickly pick it
up uh
like this by doing data.using so let's
save and go back to the browser so i'm
going to refresh here
you see we have our form and things are
okay this navigation should work
so now here we can put the name then i'm
going to use
a password that is wrong so if click
login you see we get invited credentials
the password is kept
okay so now let's enter a password
that's correct
and now you see that what happened was
we were able to get
what happens is we get an error they are
telling us that login
takes one position of argument so login
only takes in the request i believe
so if you come back here
login should take in only the request
okay so let's try again i'm going to
reload here and try to log in
so it's going to be same user
password quick login okay so you will
see that it's taking long here that is
because we are
having a collision here you see our
route our function is called login
and we also have login from django
so this is now causing an issue in our
application so let's go ahead and rename
our route so that it doesn't really mess
up with
our like the jungle views
so i'm going to stop the server here
because it's running into an issue
then we need to update the url so here
let's make sure you're updating this url
so now if we run back the application
and come back over here let's try to
login
password choose password click login
login is missing position user crazy
okay so here where is it so yeah we have
login we need to pass the user here
as you can see so let's login so
initially we're solving a wrong issue
but now i agree we got it so
let's put the user click okay and you
see that now we are logged in
and we are welcomed okay and the header
updates and now we have
the things that they just should see
when they are logged in being shown
so this is going to do it for now so in
the next video we're going to be
filtering this list by the current
logged in user we're going to be showing
the username here and also adding some
other
configuration in regards to who is
logged in so
thanks guys for watching and i'll talk
to you in the next video
hey guys welcome back last time we were
able to
refactor our create and list views to
use
one view that makes it easy to make
different
http methods or http calls one endpoint
so in this video we're going to be
adding
endpoints to edit delete and also view
one item so if we go to our views.py so
over here you guys have seen the pattern
already in generics they are different
views so we have the retrieve api view
that you can use to retrieve only one
object
so we can say okay give us an object
with id1
and then it gives it to us we also have
one
that can handle the retrieve and destroy
meaning it can have
the view and also the deletes there's
one that can handle the
view and also the update but also
there's one that can handle all of them
and this is the one we want so we're
going to import retrieve update destroy
api view
and down here we're going to set up that
class to handle the single
to do instance so you can say to do
detail api view so here we're going to
inherit from
retrieve update destroy so here one
thing we need to
tell it is the cellularizer class of
course
and these are the class properties
can be used if we need them so here we
can set up the series the class
the permission classes we also want to
have get query set
so if we wanted to like have the user
not see
an item they didn't create and we
satisfied a get query say for the object
to be sent back to the user
it's going to first have to match what
the square set is returning
and then another thing we need to
specify here is the lookup field so we
can say lookup field
so we're going to be using the id and by
the way when you come to our list you
can see we're not sending back the id
so we can send it back in our serializer
so over here you can come in and say
okay
make sure you also send back the id what
you are doing here is we are telling
jungkook's framework
that before it retrieves or does
anything with that to do item
it should be part of this query set
okay so we don't have to really worry
about things like permissions
if the user is the one who created it
this only
will be able to handle that for us so
i'm going to save this and then
add this to our url patterns so over
here instead of us now having to
put all the things like delete updates
all that stuff
we can just come over here and specify
that whenever we go to our to do slash
the id
so i'm going to have it end id here and
then now we are going to be
re we are going to be sending that to
what to do detail
view so let's rename this here and
change this one to to do
and save okay so now if you come back to
postman
i can say get one and you can see that
we get that one
let's say we say get to you can see that
it's using this id
to retrieve for us that item
okay so let's say now we want to update
to we can come over here and make a put
request
so let's say we now want to say
completed
should be true actually i think it's
it's completed
it's complete yeah it's a now we want to
say okay this one we've completed it
through like that's the cent you can set
here we get
a 200 meaning it was completed or the
record was saved
and all that stuff is being handled
within this view
okay so let's check if we can delete one
so i'm going to go to
the list so just come to the list so do
it get for all
let's say we want to delete this one
this one with the title
title so you can see the id is one so
i'm gonna come over here
and put a one and then i'll call it
delete and by the way you see here how
there is a one over there if you put one
that doesn't exist
you can see that even this use case is
being handled behind the scenes
so really the jungle market does a lot
of heavy lifting
so if we delete this one because that
now we get a 204
meaning that the object was deleted from
the server
so that's good so this view now is able
to handle
everything including having to work with
or having to work with the permissions
having to create to retrieve one delete
one and all that stuff
just by hooking it in up like this so
that's gonna do it for now so in the
next one i'm gonna be showing you how to
do things like
filtering searching and maybe paginating
these
lists so that's gonna do it i'll talk to
you later
hey guys welcome back so in this video
we're gonna go ahead and see how we can
document
our jungle rest framework api such that
when we are done working on our backend
we can avail that to
people and other people can understand
how to interact
with our api in the real scenario
whenever you work on a
rest api you want to provide a
documentation
that can be used by other developers to
know how they can
interact with the api you for example if
you had someone that was making a mobile
app for the api yeah
we've been making then they don't really
need to know about
how that api was made for them they just
need to know how can i make a request to
the backend server how can i make a
request to
basically the api so for us to be able
to provide that documentation
we have certain tools that we can use
but in our case we are going to be using
swagger so what toggle is going to be
doing is we are basically going to
describe
how our application is structured and
then it should be able to generate this
documentation
automatically for us so let's go ahead
and get started now we're going to be
using this
drf yes module so we're going to need to
install it
so i'm going to come over here and copy
this command to install it
and in our app then we can do
tip install
drf yes now make sure you're in your
virtual environment
otherwise it will not work the next
thing you're going to need to do is add
drf yes
to installed apps and i think you may
notice here is we're going to need to
make sure we have the static files app
you know insert apps
that's because drf yes of course
you will give us a ui that uses html and
css
and this is an app that django providers
that can enable
saving those static files like html and
css
so we're going to make sure that we also
have that so in our settings dot py so
i'm going to go to settings that way
now if we go to our installed apps first
we want to add
the module just installed also make sure
you have this
let's come back to the documentation so
basically what we need to do
is describe some metadata about our api
so i'm going to copy this and go to our
urls.py let's also first get it here
then we can take a look at it
so on the schema view we can first
describe what our api
is who is it for so i'm going to
change this one to to do api but feel
free to change this to your liking or
depending on the application you're
working on of course these are gonna be
different
so also we need to define the url from
which it's gonna be served on
so i'm gonna get these urls here and
we're gonna talk about
how they define a minute so i'm gonna
bring them down here
then i'm gonna change url to path
and uh wherever we have
this i'm gonna change it to
to use just the the string
and also i'm going to remove this
remove these ampersands over here we
don't need them
so if we go back to our website now you
can see we have these urls
so i'm going to go to slash swagger
like this and the reason why we're
getting forbidden is because we
configured our application
here in the settings if i could show you
so in our rest framework we had
configured our
our application to use generality
authentication
and that's why this is defaulting to
forbidden so what we want is if you go
here in the docks
you can see that we can also be able to
apply the authentication classes
so i'm going to copy that authentication
classes and here in the urls
you can go ahead and add authentication
classes then we set that to
empty okay so now if you come back to
our
slash swagger you can see that we have
our documentation
that we can give off to anyone and they
can see how they can
be able to interact with our api
so on here you can be able to come and
you try it out
and yeah you get the server to respond
which is pretty cool so
so that's how you enable swagger now you
can also use the redox version so i'm
gonna do redux
and you can see that it also is the same
but it is documented differently now
that's gonna be it you might find some
use cases where the
the initial setup may not work for you
so every time something doesn't really
work for you
when setting up documentation make sure
you come over here and you read up with
the
right configuration so one url that i
would like to show you is this one for
for json or yama format so this allows
you to export
basically our documentation into
json and that can be exported or
imported in other in other documentation
tools
so here i'm going to change this from
swagger to swagger.json
okay and then if we go to our
application now
if you come here in our app and we go to
slash swagger
to json because that we get a json file
downloaded here so i'm going to open it
up and this contains the specification
for our api
so to bring out our documentation into
our postman what we want is we want to
go to file
then we want to click on import so over
here we can drag and drop a file here
but also we can use a link so here in
the link
we can bring in our json file which we
can find at uh
we can bring in our json file which you
can find at
our site swagger.json thank you so
so swagger
if you click continue here you can see
that it gets it it can detect the format
it's in
and it's going to be imported in as a
documentation
then i'm going to click import so that's
going to go ahead and create
a correction if you don't know what your
correction is
this is just a way for postman to
organize your
your api requests so i'm gonna close
here
and now over here you can set it's gonna
go ahead and refresh and in our apis we
have this to do api
so i can click on it and down here i can
click on our documentation
and you can go ahead and explore more
here
so as you can see this is what we had in
the soga ui
and uh this is just another way that you
can use to basically look at how the api
is documented
so we also get a correction created
which is now here and we can go ahead
and test out all our endpoints
without having to really copy one by one
so that's gonna do it for this video if
you guys have any questions regarding
this
please be sure to leave them in the
comments i will check them out
thanks for watching and have a good day
hey guys what's up Chris here in this
video I'm going to show you how to solve
the common problem that we get while
sending emails and pretty much all the
other synchronous activities when we are
running a Python program so normally
when we are setting a password here you
notice that when we supply an email it
quite took some time for it tourists to
send back a response to the user so in
this one and watch out use fight on Mars
multi-threading capabilities to run the
task to send an email when it did
yesterday that's not Network bound which
will help us keep our UI like very fast
you must have noticed how long it took
to even submit to even send this email
but I will exchange that so right here
if you go back to our program I'm going
to start by importing ready to import
reading okay so right here I'm going to
set up a class so class is gonna be in a
thread so gonna this is going to inherit
from reading to thread so this is gonna
give us like all the handy GC methods to
up with threads so the first thing I'm
gonna do is define a constructor so a
constructor method a Sharia so bringing
in it
so right here you basically want to
initialize this class with the data we
are going to send in the like with a
with the email information so here I'm
going to to bring in so let's look at
our email like the objects used to send
via mail
look at this okay so you see we do email
but same so this is the object so I'm
going to instantiate the class used with
this with this email okay this is an
email it's a poem so you're going to
associate it with this image so coming
back here I'm going to bring in this so
right down here we want to set the email
so the email instance we want to set to
the object that is fasting so it's gonna
be equal to email
okay so once we have that then we need
to return we need to basically return to
the parent class constructor so right
here we can do the reading the thread
the thread error thread then in it and
pass himself okay so once we have this
we need to define a run method so this
is where we put all our project that we
want to execute when an instance of this
is created we started this is a thread
so define run run will take itself and
basically what we want is go ahead and
send the inverse so we can now do and
I'll do self dot email would send
actually I'm sure if you look at how we
are doing it down here it should be
emailed at st. then it should take in
fail 72 failure 70 just we can get
errors if there is one well if they are
so right here
so we can do so put email good sign
fill 7 3 of course and this is all we
need to do so now when we come back to
our where we are sending an email for
example here on the registration so
right here
we want to be doing it here since it's
going to go in the the thread so yeah we
can instantiate our thread class so
thread then we instantiate it to the
email tap own which you already have
then we call start on it ok so that will
execute the run of the other parents all
we need to do the same thing for the
email so scrolling down we need to do
the same thing for the for the wrists
requests pass one so right here I'm
gonna do the same thing and it should
work Samira okay so right here we exit
in here run the program again
okay let me check this one out okay so
our program is running so you come back
this site and go to reset if I submit
the same email and click Submit can see
that it's very fast you can't even
imagine so the weights working is in
spike and spreads up another thread that
doesn't run way I like the main
application is running so that allows us
to send an image in the background and
routes to respond to the user take in
real time which is good which is amazing
so now to make sure that it's working
I'm going to check out my emails so also
let me actually use sign up like with
another user so this would be just send
to hope don't have an account gmail let
go okay so it should be the image okay
so it's a variable it's available for me
at the password submit you saw how this
will take successfully created it didn't
even bother us about sending an email it
all happened
breaking an instance so if we check let
me grab my mail so you can see that the
email has come and it was like very fast
like very very fast which is awesome
which is amazing checking if we got the
registration email
see also very fast so this is going to
do it for the video this video help to
make a subscribe I will see you guys in
the next video
hey guys welcome back so in this video I
want to show you the initial I'm running
into as I viewed the front end for our
contacts list API the tribute in the
previous videos so right now I'm what
I'm gonna react up to consume the API
but when I try to make an any API
request to the deployed application on
Heroku this is what I get so for example
if I type Christ Rooney and then I put a
password like password and then click
login you will notice that the request
fails and I'm unable to connect the
server for example yeah if we actually
missed get is request someone about the
network tab and then here because that
we don't connect to the server at all so
the reason for that is that by default
jungle doesn't allow other domains to
connect to the web server normally so
what we need to do is set up a cause
policy for a web server to allow
requests from other domains to be able
to access certain resources on the owner
API server so what you're gonna do so we
are going to use this module to be able
to be fine a cause policy and allow our
website our API server to accept
requests from our local host domain so
what we're gonna do is here if you come
to this documentation they show you how
to set it up they show you how to use
the middleware and then they show you
how to configure the whitelist so the
whitelist would be the list of other
domains that you would want to make the
requests to your API so what you're
going to do is you're going to install
this and then be able to set up this but
when we look at the documentation more
you're going to see that you can also
define the whitelist using a regular
expression so this can be useful in
cases where you're making rupees from
subdomains and you would want all
subdomains of an domain to be able to
access the resources and API server also
if we look at here we can also set up
the options we allow other other domains
to to do regarding the resources we have
one now on our server so we also can can
allow all origins to access the web
server whether it's not it's generally
not a good idea so yeah so let's go
ahead and use this and see how we can
solve our issue so first
we are going to need to install it so
I'm gonna copy this here so in our
application I'm gonna run people in
store jungle cause save us so once it
installs we need to add it on install
app section I'm gonna come to settings
and then in the installed apps I'm going
to add it here so now we also have to
you to add a middle way so of course you
could define your own middle way and
after you configure this stuff from
scratch yourself this mod is highly
popular and it's actively maintained so
it's something you can rely on to to
handle these kinds of things so I'm
going to set up the middle so here I'm
gonna scroll to middle a section then
here I'm going to bring in the middle
calls media so once we are done here now
we need to set up our white list so if
we take a look here see we can set up
origin white wrists so I'm gonna copy
this one down here we can let me sit up
comments I'm gonna do cause I'm gonna
bring in this so now we can define the
domain that would want to allow on the
server to allow to request resources on
our server so right now we are working
with local host port 3000 so I'm gonna
keep proposed for 3000 so if you have
more let's say you have like a file
server and then maybe you you have a
server and then you're storing images on
a separate file server
you can also add this here such that it
can always communicate back and forth
with with your with your API server so
that's just an example but I'm going to
now leave localhost cause that's the
only use case we have for it for now so
I'm gonna build that and then I'm going
to commit this so gate add dot git
commit - and so I'm gonna say th
of course
hello low-cost for day so now I can push
these changes to beat up and once I'm
done now I can go and Ricki Pro on here
okay so here I'm gonna go to our
application on Heroku
I will reload here so I'm going to come
to the deploy section then I'm going to
choose a branch let's see which branch
in SIA
oh yeah so I'm going to redeploy I'm
actually going to trigger every deeper
so I'm going to redeploy master so now
it's going to start reading but right
now as it deploys we still have the
previous version on that server so if I
come and try it here again you can see
that we still can't fetch and forget
that the loading indicator go in a way
we will be working on that so you can
see that we still can't fetch basically
it is nothing we can do the server is
not responding to us at all this wait
for the deployment to deploy the new
changes so it has actually finished
let's wait for it to finish preparing so
now you can see that it has finished
deploying so I'm gonna not come out and
make another API request so now I'm
gonna try the same thing this so now you
can see that I get the details from the
server so you see we get the response
401 so now we are able to we are able to
communicate to the server by adding
localhost to the cause whitelist on the
web server so that's gonna do it for the
video if you need a video please give it
a thumbs up I'm mocking when they react
front-end for this I will be also
posting videos about that so if you
interested in that kind of content
consider subscribing to the channel and
I'll see you then
hey guys what's up so welcome to video 5
in our react series so in this one we'll
go ahead and set up semantic UI with the
project and also see how we can use some
of the semantic UI components like the
menu to create our navigation nav bar is
get started so if you go to react
automatic you icon you can go to getting
started and then you realize that you're
going to need to install it so let's go
ahead and reinstall it I'm gonna copy
this command here so in here I'm gonna
go to another window of the terminal and
now we can do NPM install Symantec ey
react okay so from that you are going to
need to choose a theme so we are going
to be using the default theme so you can
actually use the CD in here so you can
copy this and then include it in our you
know index.html in public so here you
can come over here we should be here and
include it let's wait for this to finish
installing so we see what we once the
installation is complete if you go back
to application suite you'll notice that
things have changed now we have this
looking a bit different our link is
looking a bit different meaning that we
have semantic UI actually configured so
you can actually decide to use to
install this low-poly so you can do that
by adding this one
so let's actually do that because this
will rely on the CDN which is fine but
in development you might be developing
offline so this is this go ahead and
install this npm install the CSS so
after you notice that after you do that
you're going to need to import it in
your app and refa I'm going to copy the
CSS and go to app juice it should be
here and I bring it in okay so that
should do the same so I'm gonna go in
the index.html and remove the the CDN
link and once I remove it and we come
back here just gonna reload yes what the
CSS has been added
meaning we should have the same thing so
now we have this same thing good okay so
let's go ahead and set up our
application napa the one that goes from
left to right so for us to do that
remember we created a folder for
components since this is going to be
used on different section of the
application you can put it in components
so I'm actually going to call it sada
so here in HIPAA we can have an index
code just so right here now we can have
a head of either component so for us to
create ads I'm going to use Bay I'm
going to put strap a a basic component
so I'm gonna call this one hit done and
this karate to do is return a menu from
Symantec so now we can return menu so in
here we can define many items so we
won't be having the login and
registration in the menu but we'll have
a create contact our just a create
contact and a logout one so you can
actually create those yeah so in the
menu you can have many items you can
have menu item so the first item will be
the one that will be showing the
application name right here so I'm going
to be calling the application through
the contacts okay so let me also have
some more
let me also have some more items this
one's going to be create contact and
this one is going to be log out okay so
if you come and take a look nothing
happens
that's because we are not reused we are
not showing this anywhere so I'm gonna
copy this so if you go to let's say our
home route so that would be in
containers contacts like here so I can
actually include this before we show the
the contacts text so you can do it done
and we can input that one from our
components so that imports it here so if
you go back the application let's see
what's happening
let's see what game is really good and
then if you got the root you see we have
the header okay
so for us to have a bigger one you can
come over here in the header and add
some props so let's give it a secondary
one
so when we give it a second everyone
it's going to go ahead and remove those
brains II saw so if we want to spread
these items to the right we can actually
do that by coming to the one one on the
right and giving it a position which I
can do position because right so the
contacts we are taking it to go to the
right so if we do root so you can see
that these are now pushed to the right
okay so we also want to have application
logo yeah before they truly contact
sticks so we can do that by coming to by
coming here so before we actually show
that menu item you can come in here and
add an image so semantic UI gives us an
image component so if you come over here
because that there is an image component
and very many things are possible with
it so I'm bringing this one up so you
guys can check it out to see what's
possible you can actually come over here
and read more about what benefits you
get so all these props can actually save
you a ton a time trying to implement
custom functionality so now we can have
the image we're gonna use one from
semantic so we need to give me the
source of course this one is gonna be
anything so this one is going to be the
logo so let me put that over here so if
we go to objects this is the input we
need okay so we will bring it in the
logo the logo so regarding the input
since now we are in the component and
it's in the assets we're going to need
to go up one directory so now if we come
back after let me bring up a server
we save this we are going to need to do
it we're going to need to import it like
this now if you go to the application
and the word because that we are loading
bay the local okay so let's actually
change its size so here you can actually
pass in like width and height
so I'm gonna pass with it when I set
this 160 if we come back reload you can
see that yeah it's looking good so if we
come here and add the pointing probe
that's gonna go ahead and add this line
down which i think is good okay so for
us to actually make this one a little
bit bigger cause looks smaller
I'm going to have to increase the size
of this so we can do that
so in here on this item you can add the
another style probe so stereo so here
you can actually see let's increase the
font two points sighs so this can be
like transfer what else
see yeah so this is big enough okay
looking good so instead of us having
these regular texts I'm going to use
buttons and also add some icons in there
so if we come back here on this on this
menu item I'm going to know what mystics
and here we can have a button so this
button will be containing an icon so you
can pass an icon prop we need to import
a pattern from semantic so in here once
you pass the icon propanol can satisfy
which icon we want so you can do icon so
the name gonna be equal to ad so this
uses actually the font awesome icons so
any icon you find on photo some will be
a variable to use here so now this is
gonna be saying ad
so if we check it you can see we have
had contact so you can have variations
of the buttons so if you come over here
let's say you go to patterns you can
have variations so if you can wave and
see you can have this is a basic one to
the standard ones so I'm going to add
the basic here so what that will do is
make this one basic so if you wanted it
in blue like we have in the main one you
can actually pass a primary here so
that's gonna go ahead and could make it
blue so getting the the blog out on we
are basically going to have this mirror
set up so in this menu item when I press
this and this is gonna be log out so
this now can have an icon of exit since
we are working out and this one we're
gonna actually give it a color here so
you can do color because I create so any
color you can give it so if you come
back you can set its now looking like
yeah so the icon is not working properly
so if you ever want to find which icon
you can use and come to icon you can
search for icons so let's see exit exit
doctor doesn't exist so let's do ho
logout yogurt a choice wanna is in the
main one one is for the book out yeah
this one so I'm gonna copy that and then
use that okay so if you come back now
notice that we have buttons everything
is looking the way we want it so one
good thing about semantic is that you
can achieve on post components on the
fly so what I mean now is you notice how
this is a button so if you wanted to use
this link in here you can actually come
in here and you add as equals
another component so now you can say
it was a component from whatever you
want to get it from so we'll be using
the link one from reactor that done so
you can import it by import link react
all set down okay so that gets it so
right here
now once you add a custom component in
the ass you can actually supply probes
here that will affect this so now since
we can navigate by supplying it to you
can add two because create contact
actually let's see how we call it so
that would be in the routes index that
will be this so this is what we're gonna
add out the tube so if you come over
here or is it the head man you can pass
get tuned to go there now if you come
you'll notice that nothing changes but
when we Hoover can be right on the lifts
bottom corner you can see it's a link so
clicking there we will navigate us okay
great
so now that we have created the header
component we can reuse it anywhere so
you can actually bring it into let's say
create contact like here see it in here
support it so if you come over you can
see everything is good just the way we
want it so we can add a link to go to
the home yeah so we can actually do that
by composing it the way we did for the
contact so I'm gonna copy the else so
right here on this menu item you can
access the player and as to so this one
will be going to their home route so if
we come over here you can see that now
it's a link clicking on it goes con
clicking here goes yeah okay so this is
how you can get started with semantic I
believe it's a cool libraries can save
you some time if your project is not is
like time bound so that's so that's
gonna do it for that video if you
enjoyed it consider giving it a thumbs
up don't forget subscribe
the channel and I'll see you in the next
video thanks for watching
so as we are testing our code we are
going to need the word to tell
how much of our code we've tested what
sections of our code are not tested and
actually be able to know that most of
the important parts of our application
have tests that are actually protecting
them from changes
that can cause side effects which
sometimes is called regression
okay so now to be able to tell what
parts of our code are tested
what what what parts are not so we are
going to be installing a package called
coverage so yeah i'm going to come in
and see if you can store coverage
okay so what that is going to do it's
going to go ahead and install the module
so once it's done now we need to run our
python manager.py
using coverage so try it you want to do
coverage
coverage run manage
dot py test like this so if we run this
it's going to go ahead and do the same
thing it was doing so also i want to be
throwing in
the verbosity flag here so that's just
supposed to be here
dash v2
okay so similarly that we don't have
more details but if we wanted to get the
coverage report
so what we could do is we could come
over here and add an ambassador
and then say coverage report
okay so now if we run this what it's
gonna do is it's going to
do the same thing but now as it finishes
the test
it's going to go ahead and now give us a
report about
our test coverage so now you see that we
have tested 44 percent
that means that we still have a lot of
things to test but
some of the things we'll notice up front
is it actually went ahead test things
that we might not need to test
so it went into the virtual environment
and tested those things so the reason
why it did that is because by default
it's going to be testing everything in
our
project so if you wanted to limit where
the tests
where where it should correct coverage
from or where where it should look for
the tests
we want to now say coverage run we can
say
coverage run then we specify a source
flag so we can say
source and then and then in front we can
specify
modules so if you want to test only
authentication we can do authentication
and then run that okay so now you see
that it's gonna run and now it's going
to be faster
and now it's only testing authentication
if you want to test another another
module what we could do is we could
come on the source flag and then we
could put a comma
and put another module so you can do
like to do so if you run this
you set now it's going to go ahead and
run and it's going to now run for our
two apps
which is what we would want to do so as
much as that is well good and fine
sometimes you might have
more apps sometimes you may have more
apps and more code to test
so always doing it like this might not
be practical all the time
so an easier way to do it would be to
specify which files we should not
correct coverage from
so let me rerun this so we see which
ones we don't really need so what we're
going to do is we're going to come to
the root of the project so that's going
to be over here
and then we're going to create a file
called coverage rc should be actually
dot coverage rc yeah then what you can
do here is you can specify
different files we want to omit so we
can do omit equals
and then down here you can put a tab and
then specify which files we don't want
to
really include so we know we don't want
to include
the files in here so what you can do is
over here you can say
i'm going to use everything in valve
okay
so now if you run back the test
remember now we are not specifying the
flag for where to correct from
and now you see that we are not
collecting from the virtual environment
so we can do this
for other files that we don't want so we
also would not want to be testing the
tests
that wouldn't really add up so we can
come over here and say we don't want to
test the tests
tests so things like static files
we don't want the the runner to even
look there
so even things like migrations because
that's code that's author generated
so we can also keep it there so also we
have these files so these
and the init we can also already omit
them from the tests
so here we can also do star data init
dot py okay so now if we run back these
tests again
you said things are quite faster and now
we are really having
some files that we really care about
okay so now this looks good but to be
able to view
which which lines are not tested you can
run this command and then you can run it
and tell it to generate for you html
so if you wanted an html file to
visualize what files are not tested what
which files are tested which lines
then you can put and coverage
html at the end so what that's gonna do
is gonna go ahead and run and when it
finishes to run
it's gonna create a folder called html
code
so over here you can see it created a
folder and this folder has all the
details about our tests so i'm going to
come to one of these and i'm going to
open it up in live server
so that's going to open it in a browser
and when it opens up
you can now see like how we are doing
with the testing
so i'm actually going to go back to the
root so we see exactly what's happening
so here we get a nice table with each
file then which
you get a nice table with each file and
how much of that code has been tested
and which ones are not tested so if we
open up a file like
views dot py for authentication you see
that we have tested out
all this so where you don't see a red
that's what is covered by tests
all this but this is not really covered
by tests at this point
so down here this is covered this is
covered
these are not covered these are not
covered
okay so now we can decide to go back and
write tests for all this
until we actually go ahead and make sure
it is 100
so to wind this video up so you would
not really want to be pushing this
folder to
github so it's also good to add it in a
git ignore so you can come and say that
html
like this and guys and now that's gonna
hide it
and now guys you can also generate xml
files so instead of
generating on the html you can generate
xml
like this and this is important if you
want to like
send this data to a coverage reporting
tool
so yeah actually we are going to be
doing that in some of the next videos so
now if we say xml it's going to create
this coverage.xml file
which is a representation for this html
so that's going to do it for now if you
enjoyed the video please give it a
thumbs up
don't forget to subscribe i'll talk to
you later
hey guys welcome back so now we have all
our crowd for the to-do's
so in this one what i want us to do is
to look at how we can do
filtering on the list that we already
have using the same endpoint we have to
retrieve
all to do's so what we want is we want
to be able to
come over here and do something like id
equals two
and be able to make a request to the
server that returns us the items
that match this filter query or we want
to be able to say
let me first bring them okay or we want
to be able to say
search for in the to do items we have
the
the word mom so here i'm gonna do search
because
i'm like this oh this should be such
like this
and then you can see we get one that
matches mom somewhere
return to us also we want to be able to
say okay
for everything you send us b go ahead
and order them by
let's say the ideas so this is some
customization that you can do client
side
and then now you can see that everything
is ordered by the id
if we say order them by completed you
can say is
complete
you will see that we get only the ones
that are completed on top and then the
ones that are completed are done
so similarly we can specify which fields
we want to be able to
order by just by changing the way our
query
the way we make the request here
okay so to get started i'm going to come
here in our project
and the first thing we are going to need
to do is to install
django filters so that's going to be
able to give us the jungle
filter backend so that provides us
different ways that we can filter
our data it gives you a lot of
flexibility you can define
things like regular expressions you
might say
i want things to to match i might you
might say
i want it to be full text so if i make a
search it can match any in these fields
that we specify
all those kinds of things so we're going
to be keeping it a little bit simple
but you guys can check in the
documentation i'll probably leave some
links
in the description so you guys can see
exactly what you can
do with this so i'm going to give you an
introduction to this then you guys can
pick up from there
so i'm going to stop the server here and
install pip install
jungle filter just going to go ahead and
install it so once you install it then
you want to go to your settings.py
and then over here you want to add
jungle
underscore filters here so when you have
this one set up then the next thing
you're gonna need to do then first bring
up the server
then you can go in our view in our list
create api view
and then we can specify a filter
backings
so one of the filter backends and then
we can set that on to
a list so first we want to first bring
in the
the django filter backend because that
has a lot of functionality already
so let's import it so from jungle
filters
go to rest framework imports
django filter backend so once we have
this then we can go ahead and we specify
the filter set fields so we can come
over here and do filter set
filter set underscore fields so now we
can set this one to
another list so want to say laser can be
able to filter by the id
also maybe the title also there is
completed
meta fields is completed this should be
is complete
yes so we run this you can see we get
the whole list
but over here we can put this query
string
and then we specify that we want to
match where the id is three
and then you can see we get that one
return for us so it's using
what is this right here in the filter
set and it's just starting by where the
id is three
so similarly we can use the title but if
we try to use something that doesn't
exist let's say you see how the
description is this
if we came here and did dc
equals this because that it's not
matched
but if we come over here and add that we
can also we also
should be able to match by to filter by
the description and save
and try to make the same request because
that now it matches one
so similarly we can we can go ahead and
and filter by any of these attributes so
here we can have something like
is complete equals true
[Music]
so if we do that you can see that now it
brings this one but if we say false
it brings the other one that are all not
complete
okay so that's how we do that a lot of
the times you're going to want to
return items that match a specific such
criteria
so let's say maybe a user is doing a
search on your website
so over here you can go ahead and and
specify
a search normally you would want to come
here and specify a search
and you want to search for something
like like sleep so if we do that you'll
notice that
what we get is almost everything and
that's because we have not enabled the
search filter
on our filter back-ends so what we want
to do
is we want to come over here and go to
rest framework
where we import permissions and also
import filters
okay so in the filter back ends what we
can do
is we can go there and add there the the
search filter so you can do filters
dot search filter
like this so any specific search filter
then you want to specify the search
fields
so i'm going to go ahead and duplicate
this and then specify here
search fields search fields
so when we have that now we can come
here and search for sleep and you can
set now we match
sleep if we search for something else
like test
you can set it's not much anywhere so
the other thing you would want to do
is to specify the way your items are
retrieved so i'm going to just clear it
out so see what's going on here let's
say you want to order them
in ascending order for the ids you would
want to come over here
and add something like ordering
equals maybe id so by default you see we
use the
the ordering order we use the order for
the created bar
created it but if you wanted to say
maybe i want
i want two to come first or three
to come second that kind of thing you
also want to specify
the ordering fields here so i'm going to
keep the same thing
but we just change the property name so
this one can be ordering
and also we need to include the ordering
backend so you can say filters dot
ordering
filter okay like this so now when we
save this we can come over here and say
okay go ahead and order by the ids and
then you can see that things now change
you can't be able to do a lot of things
here so that's gonna do it for this one
i hope it showed you that all the things
that you might have been thinking of
are possible and they are really easy to
implement if you have any
any advanced use cases be sure to look
it up on
on google google is always your friend
and sure you're going to get
some good results so thanks guys for
watching i will talk to you
later
hey guys welcome back so in this one
we're going to go ahead and see how to
refresh a token
like you so whenever we log in a user we
give them two tokens the access and the
refresh
now the access we've already seen how
it's going to be used we can use it to
access protected endpoints like this
slash me since the access token grants
access to
the resources on our server we always
want to make it short-lived
say that in any case that someone gets
access to it they still wouldn't use it
to access resources on our server
for a long time so just something to
mention here
you see how we have all these
configurations here now the one we set
was only the secret key but if you
wanted to set
uh anything else like any other any
other config to the
to the module be sure to check one of
these
so for example you can see access tokens
by default will
will take 15 minutes to expire but we
could change that if we wanted to
and the recommendation is to always make
it as less than this
as possible and then you can see that
the refresh tokens can be
like 13. so we can always use this to
refresh the refresh token
to refresh the access tokens so
to now create an endpoint refresh the
access tokens i'm going to go to
our code so over here
we will have another endpoint it's gonna
be slash both
slash both then dots we can have it dot
a post so i'm gonna have a post here
now here we wanna go to when a user goes
to slash token slash
refresh so let's create a function to
handle that
so refresh token user token one thing
here
we want the user to only access this
endpoint
by giving us a refresh token now for us
to enforce that what they give us here
is a refresh
token we are also going to use a jwt
required
this decorator here on this very view
but the difference here is here we are
going to we are going to expect them to
give us a refresh
we are going to we are going to expect
them to give us a refresh token
so we're going to pass refresh equals
true so to handle this what we want is
to first get who the user is so we can
do identity
then when you do get get the identity
thing should give us the user id
so now we can create a new access token
so we can just say access token
should we create access token and in
this case we pass the identity
which should be our identity and uh
now that we have a new access token then
we can return to the user
you can just say return to 25 then let's
have the access token for the user
then it's going to be the new one we
just generated for them
and i will send back at 200 so http 200
okay
if we come back to our postman so if we
do a post remember we need to send the
refresh token
so you can see that it goes right to
validate that we are not sending it
so in uh in oauth we can choose we want
to use bearer token
and we can if we try to use this notice
that it fails this one is expect
so we need to be using a refresh token
that is valid so i'm going to log in
here
and that's going to give us a new
refresh token and now we can use this
under this endpoint we can go ahead and
use that and now when we click
send you can see we get a new access
token
and this new access token is associated
with the very same user
who logged in here so that is how we
refresh the tokens
so if you wanted to use a different
method for this it's just up to you you
can just click it
doesn't really matter since we are not
even posting anything
so that's how we refresh the user's
token so i'm going to be posting the
video here
if it helped you out give it a thumbs up
and forget to subscribe the next
video we are going to start working with
the bookmarks creating bookmarks
and retrieving bookmarks and all that
fun stuff
hey guys welcome back so last time we
saw how we can quickly change the
package name or the application id of a
react native app from what it gives you
to something that you want so in this
one we are going to see how to
we can quickly change the app display
name on android and also on ios so
currently if you look at our application
here you notice that our application
starts with a small r and when you look
at the other apps there's not
no any other app like that so we might
want to
change this one to use a capital letter
at the start just to follow the other
convention of the other apps so
on ios you will notice that it also
starts with a small
later so so if you wanted to change this
to something else that we want something
that looks better we could do that so
there we do that is on android we want
to go to
strings.xml so search for strings.xml
this is where your app name will be
so you can come over here and rename it
to anything you want so you can even say
error in space contacts
like this and then if we run it
then it's going to go and update that so
if we go to if we want to change for the
ios we want to go to the info.plist file
so info.plist then we want to look for
we want to look for cfb bundle display
name
then we can come here and change it so
we can do something like rn space
contacts like that and then we can rerun
the ios side so here
i'm going to just come in and say yan
ios
android has already come so i'm going to
open it up in visor
so if i close it you notice that the app
name changed to our end contacts
which is what we wanted okay so done for
android
that was quick so it's opening up on ios
successfully build the app
so let it boot up now that it's up if we
go ahead and check
what name is using you will see that it
is it is using our custom name
so that's gonna do it for the video i
hope you found this video helpful if you
did please consider giving the thumbs up
don't forget to subscribe
right don't forget to subscribe look you
guys always forget to subscribe
so don't forget subscribe and i'll talk
to you in the next
one
hey guys what's up so in this one we're
gonna be talking about how to handle
logout
on our back end rest api which is
powered by jwt
so normally when it comes to logout on
applications
you would have like a session that you
can terminate
when a user clicks logout and then they
cannot be able to access other parts of
the application
when that session is not active but when
it comes to jwt
everything is stateless meaning that we
don't actually keep
the state of the user's authentication
in the application
memory so what happens is we create
these access tokens and send them back
to the user
so a user can use this to access any
endpoint in our application
but then also we send them a refresh
token so the idea
here is we should make the access token
very short-lived
meaning that it should be expiring
really fast so that we don't actually
need to
have to keep track of of this access
token expiry time
or whenever is using it separately so
the idea for the logout
is we're going to need to find a way of
blacklisting the refresh token such that
at any point when the access token
expires
there will be no way of refreshing it
other than having to re-authenticate
again
okay so that's what we're gonna do so to
start with we are using
the simple jwt module and it comes with
the blacklist
app so what we want to do is we want to
include this in
our installed apps so i'm going to go
back to application go
back to our settings for there you want
to make sure you have it in your
in your installed apps then after you
add that you want to run migrations
so i'm going to python manage py make
migrations actually
migrate so that's going to go ahead and
run all our migrations so once that's
done then we can go ahead and create a
view that
user will use to log out so i'm going to
go in the authentication views.py then
i'll create another api view
so here i'm going to have a new class
this is gonna be called logout
api view so
we're in here from generics generic api
view because we want to under our
post but the user is gonna be sending a
post in order to log out so once we have
this now we can define a few things one
will be the stereo eraser class
so we're gonna have serializer class
we're gonna set it to logout serializer
and we're gonna create this
cloud we want to make sure that the user
can only access this endpoint when they
are logged in
so this means that we ensure that they
are really logged in and we are actually
practicing their refresh token so what
we do
here is we want to to specify
permissions so we can do permission
classes
then we can do permission authenticated
permissions dot is authenticated
okay so once you've said once we specify
those now we can handle our post
so dev post self and request
and then here of course we want to send
everything now to the serializer
so we can have city eraser because
select the serializer class then we want
to send data which have been requested
data
as normal and then we want to run the
validations
by writing these valid raised exceptions
if they are
and then we can conserve the save this
will call the
create method on the blacklist model so
that should be serious if not save sub
server saves that
f okay so once we have this and
everything is fine
we can return a response to the user so
we can return so we can send a message
but it's optional so what you can do now
is just send a status code so status
will be
yeah so so the status is going to be no
content so you can do status
dot http
http not hp http
204 this one
okay so let's go and create the
serializer make sure we
are importing it from somewhere it is
so here you can put the comma and have
it say look outside the eraser
and in the serializers first we need to
create it
so i'm going to go down and have a class
tell you riser
so let's import so seriously
dot serializer once we are here we need
to suspect that the user should send us
a
should send us a refresh token it's
going to be a chat field
so once we have that now we can do the
valid date
so def by date
so in the validate what you want to do
of course it gets the data that the user
sends
so what we want to do is we wanted this
refresh token to the one that the user
sends us
so we kind of save the token equals
address then that's gonna be refresh
so we want to make sure this is what
they're sending so once we have that now
we can return it
here we can address and then since we
called safe on the view
we called save on this eraser from the
view we need to handle the save so the
devsev
itself and then texting other
arguments so
once we have that now we need to use the
refresh token
to blacklist this token so i believe
we've already
imported refresh token so you want to do
refresh token and then you give it the
token
so that's gonna be yourself the token
and then you want to call the blacklist
so let's make sure i'm putting refresh
token up here
so that will be from from rest framework
import refresh token like that okay so
this will be able to
request our tokens but we want to make
sure that this doesn't throw an error so
just wrap it in a try except
and then if there is an error then we
will return the error
but otherwise
so let's accept token error
okay i want to make sure you're
importing it too so i'm going to come
over here
and import it from this framework simple
diabetes token tokens
so if we can't save it then we can
return surface failure
and then we give it the message so we
can say something like but again
okay looking good oh this should be
address
because there can be many okay so once
we have this we need to add it to our
url
say that the user can access it so i'm
going to duplicate the
login and then call it logout log
out then the view has to be logout
api as view
okay so let's import it make sure it's
imported
not sure if this is how we called it we
want to make sure if we come here
that's the name we are giving it
which it is so good so at this point
when we run the application
so i'm gonna run its python manager ui
run server we need to import permissions
in our view
so here we can do something like from
risk remote input permissions
or we can put it here
so if you run back the app it's gonna
boot up so if i click on it
and come over here you will see that we
have a logout added to our own
and then we need to send a refresh
yeah so what happens is here you can
send any refresh string
for example if i send this it should
fail so you will see that
it needs the user to be logged in
already so we want to come over here and
maybe
log in a user quickly let's say we log
in here you see that we get the tokens
and everything
so you will want to send you would want
to
make sure you're sending the access
token in the headers
so you can come here and simulate a user
login so we have vera here
and then have the token and now
the way you access the logout api is you
want to go to logout and then you need
to send a refresh token
so i can come over here and then you
will be saving the refresh token
somewhere
so on the logout route you send it
through the api
so i'm going to come and repress this
like this and then you execute it
so you see that we get a 204 meaning
that
our view worked okay so the other thing
you want to do is you want to specify a
message that will be sent to the user
when this
fails uh so what happens is when we say
fail fail is going to be looking for a
messages dictionary
in ours on our site eraser so what you
can do is we actually need to make this
on a key
so what what we want to do is we can
define the messages here so we can have
something like default
error messages and then here we find our
dictionary and now we can have
our keys and then the error values so
you can have
this key for the bad token and then the
value
would be the error so here we can have
token
[Music]
is expired
or invalid okay so that's how that works
if you don't want to save this fail then
you can just raise a validation error
from here by using
raise validation error and the view will
still be able to send it to the user
showing you what happens on our jungle
admin or in the database
when we run my grade it's going to go
ahead and create the blacklisted tokens
and then they're sending tokens
relations so this keeps track of all the
tokens that have been blacklisted
and these doubles are checked every time
a user is accessing a row that needs
him to be logged in meaning that if they
try to use a token
whose refresh was back listed and has
expired
then it won't be able to get the
resources
so one question that is remaining you
might be asking what's happening what's
happening these tokens because they are
only being stored
would that be taking up a large amount
of space on our in our database and yes
you're right so we need the way to
actually be clearing out these tokens
so since our access tokens are
short-lived you want to make sure
actually they are so if i can go to my
settings
you should have a setting for that so
once make sure that when we log out the
access token can only be used for the
next few minutes so other than that if
you want to
clear out all the tokens that have been
saved in the database you might set up
like a chrome job
so that's a process that runs after
every certain time you define
and then it it deletes out the things
from the database
so the simple uwt module provides us a
management command
and you can run that by let me show you
so python
money dot py so you want to so you want
to run it from python manager py then
you call fresh expired tokens
so when you run this this is gonna go
ahead and delete all the
x expired tokens that have been saved in
our data
the expired token that have been saved
in on our database and that's going to
clean it up may run
back the server again so if we come to
our
our admin and reload here you will see
that the token has been deleted
and it's not there anymore so that's
gonna be it guys if you enjoyed the
video please give it a thumbs up don't
forget subscribe and i'll talk to you
soon
bye
